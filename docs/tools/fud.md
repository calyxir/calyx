# FUD: The Calyx Driver

Working with Calyx involves a lot of command-line tools. For example, an
incomplete yet daunting list of CLI tools used by Calyx is:

- The Dahlia & the systolic array compilers
- Calyx compiler and its various command line tools
- Verilator, the Verilog simulation framework used to test Calyx-generated designs.
- Waveform viewers to see the results of simulation

`fud` aims to provide a simple interface for using these toolchains and
executing them in a pipeline. The source for fud is
[here](https://github.com/cucapra/futil/tree/master/fud).

## Installation
You need [Flit](https://flit.readthedocs.io/en/latest/) to install `fud`. Install it with `pip3 install flit`.

You can then install `fud` with

```bash
flit install
```
(If using this method to install `fud`, `pip3` should be version >= 20)

If you are working on `fud` itself, you can install it with a symlink with:
```bash
flit install --symlink
```

You can also install `fud` with

```bash
flit build
pip3 install dist/fud-0.1.0-py3-none-any.whl
```

Finally, point `fud` to the root of the repository:
```
fud config global.futil_directory <full path to Calyx repository>
```

## Configuration

Fud uses a global configuration file to locate tool paths and default values.
To view the configuration, use `fud config`.

**Check.**
Fud can automatically check if your configuration is valid and can help you set
certain variables. Perform this check with:
```bash
fud check
```

**Viewing keys.**
To view the current value of a key, use `fud config key`. For example, the
following shows the path to the Calyx compiler.
```bash
fud config stages.futil.exec
```

**Updating keys.**
Keys can be updated using `fud config key value`.
For example, the following command updates the path to the Calyx compiler.
```bash
fud config stages.futil.exec ./target/debug/futil
```

## Adding Backends

`fud` wraps both frontends and backends for Calyx. For a minimally useful
`fud` installation, you need to configure the Verilator backend and accompanying
tools.

**Verilator.**
We use the open source [Verilator](https://www.veripool.org/wiki/verilator)
tool to simulate Verilog programs generated by the Calyx compiler.
Install Verilator by [following the instructions](https://www.veripool.org/projects/verilator/wiki/Installing).

By default, `fud` will use the `verilator` executable to run Verilator. To
use a different binary, configure the path by:
```
fud config stages.verilog.exec <binary>
```

**Vcdump.**
Vcdump is a tool for converting `vcd` (Value Change Dump) files to JSON for
easier analysis with the command line.

Install it with:
```bash
cargo install vcdump
```

## Adding Frontends

Calyx programs are generated by frontends. We have implemented several
frontends that can be configured with `fud`.

**Dahlia.**
In order to use the Dahlia frontend with Fud, first
[install Dahlia](https://github.com/cucapra/dahlia).
Once Dahlia is compiled, point `fud` to the Dahlia compiler binary:
```bash
fud config stages.dahlia.exec <full path to dahlia repo>/fuse
```

**Systolic Array Generator.**
The systolic array generator frontend is automatically configured by `fud`
since it lives in the same repository as the Calyx compiler (under
`frontends/systolic-lang`).

## Adding Synthesis Backends

`fud` supports synthesis backends to generate resource utilization numbers
for Calyx designs.

**Vivado.**
By default, `fud` looks for, and invokes, the `vivado` binary. If you have
installed `vivado` with a different name, configure it using:
```shell
fud config stages.synth-verilog.exec <binary>
```

`fud` can also invoke `vivado` installations on remote machines if it is not
available locally on your machine.
Configure the name of the host machine and the user name by:
```
fud stages.synth-verilog.ssh_host <name of host machine>
fud stages.synth-verilog.ssh_username <user name>
```


## Usage
These commands will assume you're in the root directory of the Calyx
repository.

**Compiling Calyx.**
Fud wraps the Calyx compiler and provides a set of default compiler options
to compile Calyx programs to Verilog.

```bash
# Compile Calyx source in the test simple.expect
# to Verilog. We must explicitly specify the input
# file type because it can not be guessed from
# the file extension.
fud exec examples/futil/simple.expect --from futil --to verilog
```

Fud can explain its execution plan when running a complex sequence of
steps using the `--dry-run` option.
```bash
# Dry run of compiling the Dahlia dot product file
# to Calyx. As expected, this will *only* print
# the stages that will be run.
fud exec examples/dahlia/dot-product.fuse --to futil --dry-run
```

**Simulating Calyx.**
Fud can compile a Calyx program to Verilog and simulate it using Verilator.


```bash
# Compile and simulate a vectorized add implementation
# in Calyx using the data provided,
# then dump the vcd into a new file for debugging.
# === Calyx:   examples/futil/vectorized-add.futil
# === data:    examples/dahlia/vectorized-add.fuse.data
# === output:  v-add.vcd
fud exec \
  examples/futil/vectorized-add.futil \
  -o v-add.vcd \
  -s verilog.data examples/dahlia/vectorized-add.fuse.data
```

**Simulating Dahlia.**
The following command prints out the final state of all memories by specifying
`--to dat`.

```bash
# Compile a Dahlia dot product implementation and
# simulate in verilog using the data provided.
# === Dahlia: examples/dahlia/dot-product.fuse
# === data:   examples/dahlia/dot-product.fuse.data
#     (`.data` is used as an extension alias for `.json`)
fud exec \
  examples/dahlia/dot-product.fuse \
  --to dat \
  -s verilog.data examples/dahlia/dot-product.fuse.data
```

### Working with Stages

Fud is structured as a sequence of stages that transform inputs of one form
to outputs.

**Stages.**
`fud` transforms a file in one stage into a file in a later stage.
The `--from` and `--to` options specify the input and output stages to the
`fud exec` subcommand.
Use `fud info` to view all possible stages.

**Guessing stages.**
`fud` will try to guess the starting stage by looking at the extension of the
input file and output file (if specified using the `-o` flag).
If it fails to guess correctly or doesn't know about the extension, you can
manually set the stages using `--to` and `--from`.
