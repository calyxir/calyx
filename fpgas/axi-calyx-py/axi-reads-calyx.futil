// ###
// This file contains the components needed to perform read transacitons via AXI.
// Current goal is to create a cocotb testbench that tests correctness of this.
// See https://github.com/cucapra/calyx/issues/1733 for more information.
//
// This wrapper assumes it is part of a dot product computation with vectors of
// length 16
// It assumes a bus data width of 32
// This is largely a work in progress and as of Nov 20 2023 is not intended to
// actually be used for anything
// ###

import "primitives/core.futil";
import "primitives/compile.futil";
import "primitives/math.futil";
import "primitives/memories.futil";


//this goes m->s unlike read channel
component m_arread_channel(
  ARESET: 1,
  ARREADY: 1
) -> (
  ARVALID: 1,
  //This needs to be 64, see link below `m_axi` section.
  ARADDR: 64,
  //2^ARSIZE is bytes used in transfer. For memory-mapped AXI (which is what we
  //are doing I believe), should match width of data bus (to shell?, so 32 wide? This
  // is 3'b010)
  //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
  // for restrictions
  ARSIZE: 3,

  ARLEN : 8, //in AXI4 this is 8 bits, 1-256 transfers in requested transaction.
  
  // 00 for fixed, 01 for incrementing, 2 for wrap, needs to be incr)
  ARBURST : 2) {
  cells{
      is_arvalid = std_reg(1);

      //gets set high with ARVALID and remains high
      arvalid_was_high = std_reg(1);
      //todo(nathanielnrn): we get this from `s_axi_control`. Need to check 
      //how we known actual address
      //should probably live in `s_axi_control` but for now will live here
      ref base_addr = std_reg(64);
      //also need to figure out how to calculate this. Prob from yxi.
      //this is sent to shell as opposed to txn_n below which is internal
      txn_len = std_reg(8);

      //number of txns we wants to occur before entire m_arread_channel is done
      //TODO(nathanielnrn): We want this txn_n to be passed by reference, but this is not feasible for a const. Later can use a reg.
      txn_n = std_const(32,1);
      txn_count = std_reg(32);
      perform_reads = std_neq(32);
      txn_adder = std_add(32);

      block_transfer_done_and = std_and(1);
      //need to put and out into a reg to avoid combinational loops
      bt_reg = std_reg(1);


  }

  wires{

      ARVALID = is_arvalid.out;

      //prob not needed, see do_ar_transfer
      //group assert_val {
      //    is_arvalid.in = 1'b1;
      //    is_arvalid.write_en = 1'b1;
      //    assert_val[done] = is_arvalid.done;
      //}
      
      group deassert_val {
          is_arvalid.in = 1'b0;
          is_arvalid.write_en = 1'b1;
          deassert_val[done] = is_arvalid.done;
      }

      //TODO: prob not needed, delete, see do_ar_transfer
      //group block_transfer{
      //    block_transfer_done_and.left = ARREADY;
      //    block_transfer_done_and.right = is_arvalid.out;
      //    bt_reg.in = block_transfer_done_and.out;
      //    bt_reg.write_en = 1'b1;
      //    block_transfer[done] = bt_reg.out;
      //}

      group reset_bt {
          bt_reg.in = 1'b0;
          bt_reg.write_en = 1'b1;
          reset_bt[done] = bt_reg.done;
      }

      //this asserts valid and defines all inputs correctly
      //because valid should not be deasseretd until handshake occurrs
      // should be all one group
      //this contains blocking logic previously in its own group
      group do_ar_transfer {
          //assert ARVALID
          is_arvalid.in = !(is_arvalid.out & ARREADY) & !arvalid_was_high.out ? 1'b1;
          //TODO: should be able to get rid of &arvalid_was_high
          is_arvalid.in = is_arvalid.out & ARREADY & arvalid_was_high.out ? 1'b0;
          is_arvalid.write_en = 1'b1;

          arvalid_was_high.in = !(is_arvalid.out & ARREADY) & !arvalid_was_high.out ? 1'b1;
          arvalid_was_high.write_en = !(is_arvalid.out & ARREADY) & !arvalid_was_high.out ? 1'b1;


          //drive output signals for transfer
          ARADDR = base_addr.out;
          ARSIZE = 3'b010; //see link above, needs to match data width to host.
          //For now this can be taken from .yxi, as size of mem.
          //If we want to use bigger mems need to be able to update base addr and
          //make multiple calls.
          ARLEN = txn_len.out;
          ARBURST = 2'b01; //incr


          //done when ARREADY and arvalid.out is high.
          //TODO(nathanielnrn) is this okay? Will this keep everything high for a single cycle?
          block_transfer_done_and.left = ARREADY;
          block_transfer_done_and.right = is_arvalid.out;
          //TODO(nathanielnrn): Can we get rid of bt_reg? this was used before for
          //parrallel assignment which we fixed? Maybe? Not sure
          bt_reg.in = block_transfer_done_and.out;
          bt_reg.write_en = 1'b1;
          do_ar_transfer[done] = bt_reg.out;
      }


      //txn bookkeeping.
      //We are done performing reads when txn_count == txn_n
      group txn_count_init {
          txn_count.in = 32'b0;
          txn_count.write_en = 1'b1;
          txn_count_init[done] = txn_count.done;
          
      }

      group txn_len_init {
          //TODO(nathanielnrn): For dot product this should be 1 if data  bus width is 512
          //otherwise should be appropriately set. 15 is good for word wide data bus. We'd
          //expect 16 transfers? Length is ARLEN + 1
          txn_len.in = 8'd15;
          txn_len.write_en = 1'b1;
          txn_len_init[done] = txn_len.done;
      }

      group txn_incr {
          txn_adder.left = txn_count.out;
          txn_adder.right = 32'b1;
          txn_count.in = txn_adder.out;
          txn_count.write_en = 1'b1;
          txn_incr[done] = txn_count.done;

      }

      comb group check_reads_done {
          perform_reads.left = txn_count.out;
          perform_reads.right = txn_n.out;
      }
  }

  control{
      //probably for now just want a counter and done of m_read_channel_check.
      //Question: Is there a way offering more flexibility than just a counter?
      seq{
          txn_count_init;
          txn_len_init;
          while perform_reads.out with check_reads_done{
              seq{
                  reset_bt;
                  //assert_val;
                  //block_transfer;
                  do_ar_transfer;
                  deassert_val;
                  txn_incr;
              }
          }
      }
  }
}




component m_read_channel(
  ARESET : 1,
  RVALID : 1,
  RLAST  : 1,
  RDATA  : 32, //TODO(nathanielnrn): figure out where we want to shrink to 32
  RRESP :  2,  //Note: This is generated in subordinate! had this backwards in earlier version
) -> (
  RREADY : 1,
) {
  cells {
      //16 is due to dot-product vector length assumption
      ref data_received = seq_mem_d1(32, 16, 64);
      is_rdy = std_reg(1);
      ref curr_addr = std_reg(64); //TODO(nathanielnrn): not used in axi, only internal
      
      n_RLAST = std_reg(1);
      //TODO: ew. Can we get rid of this? This is needed because RLAST is set high
      // while we are servicing the previous request. Which is kinda weird if you think about it
      // but makes sense cause RDATA changes and is considered valid
      n_RLAST_delayed = std_reg(1);

      //TODO: get this width from yxi
      read_data_reg = std_reg(32);


      //TODO(nathanielnrn): This is a hack to allow things to compile with bit widths.
      //Still need to figure out how we actually want to be shrinking from 512 to 32
      //NOTE: this takes [31:0] by definition
      //rdata_slice = std_slice(512,32);
      curr_addr_adder = std_add(64);



      block_transfer_done_and = std_and(1);
      bt_reg = std_reg(1);

  }
  wires{

      RREADY = is_rdy.out;
      data_received.read_en = 1'b0;
      //comb group not_rlast{
      //    n_RLAST.in = RLAST;
      //}

      //note RREADY must be registered.
      //Want this to always be running for life of program. So how do we determine doneness?
      //This should want to look at done signal of entire program, which will depend on this group being done.
      //Don't think we can just wrap this as a top level par block for that reason.

      //group assert_rdy{
      //    is_rdy.in = 1'b1;
      //    is_rdy.write_en = 1'b1;
      //    assert_rdy[done] = is_rdy.done;
      //}

      //group deassert_rdy{
      //    is_rdy.in = 1'b0;
      //    is_rdy.write_en = 1'b1;
      //    deassert_rdy[done] = is_rdy.done;
      //}

      group init_n_RLAST {
          n_RLAST.in = 1'b1;
          n_RLAST.write_en = 1'b1;
          init_n_RLAST[done] = n_RLAST.done;
      }

      //group init_n_RLAST_delayed {
      //    n_RLAST_delayed.in = 1'b1;
      //    n_RLAST_delayed.write_en = 1'b1;
      //    init_n_RLAST_delayed[done] = n_RLAST_delayed.done;
      //}


      group reset_bt {
          bt_reg.in = 1'b0;
          bt_reg.write_en = 1'b1;
          reset_bt[done] = bt_reg.done;
      }

      //NOTE: xVALID signals must be high until xREADY is high as well, so this works
      //because if xREADY is high (is_rdy.out) then RVALID being high makes 1 flip
      //and group will be done by bt_reg.out
      group block_transfer {
        //set RREADY high
        //TODO: tehcnically we can make RREADY depend on on RVALID (but not vice versa).
        //Could we simplify this we just making things ready when we are in
        //block_transfer && RVALID?

        //NOTE: is_rdy.in = 1'b1; does not work, it leaves RREADY high for 2 cycles
        is_rdy.in = !(RVALID & is_rdy.out) ? 1'b1;
        is_rdy.in = RVALID & is_rdy.out ? 1'b0;
        is_rdy.write_en = 1'b1;


        //store the data we want to write
        //rdata_slice.in = RDATA;
        read_data_reg.in = RDATA;
        read_data_reg.write_en = is_rdy.out;

        //update n_RLAST reg
        n_RLAST.in = RLAST ? 1'b0;
        n_RLAST.in = !RLAST ? 1'b1;
        n_RLAST.write_en = 1'b1;
        

        //we want this to be continuous assignment to is_rdy.in, but thats not possible
        block_transfer_done_and.left = is_rdy.out;
        block_transfer_done_and.right = RVALID;
        bt_reg.in = block_transfer_done_and.out;
        bt_reg.write_en = 1'b1;
        block_transfer[done] = bt_reg.out;
        //block_transfer[done] = !(is_rdy.out & RVALID) ? 1'b0; //good to be explicit and not rely on undefined behavior
      }

      group receive_r_transfer{
          //set RREADY low;
          is_rdy.in = 1'b0;
          is_rdy.write_en = 1'b1;


          //TODO(nathanielnrn): get addr from register in ARCHANNEL?
          data_received.addr0 = curr_addr.out;
          data_received.write_en = 1'b1;
          data_received.write_data = read_data_reg.out;
          receive_r_transfer[done] = data_received.write_done;



          n_RLAST_delayed.in = n_RLAST.out;
          n_RLAST_delayed.write_en = 1'b1;
      }

      group incr_curr_addr{
          curr_addr_adder.left = 64'd1 ;
          curr_addr_adder.right = curr_addr.out;
          curr_addr.in = curr_addr_adder.out;
          curr_addr.write_en = 1'b1;
          incr_curr_addr[done] = curr_addr.done;
      }
  }
  control{
      init_n_RLAST;
      //init_n_RLAST_delayed;
      //XXX(nathanielnrn): is this it? Do we need any other conditions?
      while n_RLAST.out{
          seq{
              reset_bt;
              //assert_rdy;
              block_transfer;
              //deassert_rdy;
              receive_r_transfer;
              incr_curr_addr;
          }
      }
  }
}

//TODO(nathanielnrn): this is axi_wrapper, prefer to use @toplevel attribute but its not working
component main(
    m_ARESET : 1,
    m_ARREADY : 1,

    m_RVALID : 1,
    m_RLAST : 1,
    m_RDATA : 32,
    m_RRESP : 2,
    //NOTE: Only used for cocotb compatability, doesn't do anything within the wrapper itself currently.
    m_RID : 1,
) -> (
    m_ARVALID : 1,
    //This needs to be 64, see link below `m_axi` section.
    m_ARADDR: 64,
    //2^ARSIZE is bytes used in transfer. For memory-mapped AXI (which is what we
    //are doing I believe), should match width of data bus (to shell?, so 512 wide?
    //which is 3'b110?)
    //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
    // for restrictions
    m_ARSIZE: 3,

    m_ARLEN : 8, //in AXI4 this is 8 bits, 1-256 transfers in requested transaction.

   // 00 for fixed, 01 for incrementing, 2 for wrap, needs to be incr
    m_ARBURST : 2,
    m_RREADY : 1,
    //NOTE: Only used for cocotb compatability, doesn't do anything within the wrapper itself currently.
    m_ARID : 1
) {
    cells{
        vec1_data = seq_mem_d1(32,16,64);
        // Not used currently
        //vec2_data = seq_mem_d1(32,16,4); 
        output_data = seq_mem_d1(32,1,0);

        curr_addr = std_reg(64); //TODO(nathanielnrn): figure out where this comes from, see generated toplevel and kernel interface requirements below.
        base_addr = std_reg(64);

        read_channel = m_read_channel();
        arread_channel = m_arread_channel();

    }

    wires{

        m_ARID = 1'b0;

        group set_curr_to_base_addr{
            curr_addr.in = base_addr.out;
            curr_addr.write_en = 1'b1;
            set_curr_to_base_addr[done] = curr_addr.done;
        }
    }

    control{
        seq{
            //TODO(nathanielnrn): find out what inputs we need to hook up to properly interface. Can probably see here:
            //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
            //and also base off of https://github.com/cucapra/calyx/blob/master/tests/xilinx/gen-verilog/dot-product.expect
            //which probably works? Needs to be tested
            invoke arread_channel[base_addr = base_addr]
            (
            ARESET = m_ARESET,
            ARREADY = m_ARREADY
            )
            (
            ARVALID = m_ARVALID,
            ARADDR = m_ARADDR,
            ARSIZE = m_ARSIZE,
            ARLEN = m_ARLEN,
            ARBURST = m_ARBURST
            );
            set_curr_to_base_addr;
            invoke read_channel[data_received = vec1_data, curr_addr = curr_addr]
            (
            ARESET = m_ARESET,
            RVALID = m_RVALID,
            RLAST = m_RLAST,
            RDATA = m_RDATA,
            RRESP = m_RRESP
            )
            (
            RREADY = m_RREADY
            );
        }
    }


}
