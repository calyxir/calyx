// ###
// This file contains the components needed to perform read transacitons via AXI.
// Current goal is to create a cocotb testbench that tests correctness of this.
// See https://github.com/cucapra/calyx/issues/1733 for more information.
//
// This wrapper assumes it is part of a dot product computation with vectors of
// length 16
// This is largely a work in progress and as of Nov 20 2023 is not intended to
// actually be used for anything
// ###

import "primitives/core.futil";
import "primitives/compile.futil";
import "primitives/math.futil";
import "primitives/memories.futil";


//this goes m->s unlike read channel
component m_arread_channel(
  ARESET: 1,
  ARREADY: 1
) -> (
  ARVALID: 1,
  //This needs to be 64, see link below `m_axi` section.
  ARADDR: 64,
  //2^ARSIZE is bytes used in transfer. For memory-mapped AXI (which is what we
  //are doing I believe), should match width of data bus (to shell?, so 512 wide?
  //which is 3'b110?)
  //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
  // for restrictions
  ARSIZE: 3,

  ARLEN : 8, //in AXI4 this is 8 bits, 1-256 transfers in requested transaction.
  
  // 00 for fixed, 01 for incrementing, 2 for wrap, needs to be incr)
  ARBURST : 2) {
  cells{
      is_arvalid = std_reg(1);
      //todo(nathanielnrn): we get this from `s_axi_control`. Need to check 
      //how we known actual address
      //should probably live in `s_axi_control` but for now will live here
      ref base_addr = std_reg(64);
      //also need to figure out how to calculate this. Prob from yxi.
      //this is sent to shell as opposed to txn_n below which is internal
      txn_len = std_reg(8);

      //number of txns we wants to occur before entire m_arread_channel is done
      //TODO(nathanielnrn): We want this txn_n to be passed by reference, but this is not feasible for a const. Later can use a reg.
      txn_n = std_const(32,16);
      txn_count = std_reg(32);
      perform_reads = std_neq(32);
      txn_adder = std_add(32);

      block_transfer_done_and = std_and(1);
      //need to put and out into a reg to avoid combinational loops
      bt_reg = std_reg(1);


  }

  wires{

      ARVALID = is_arvalid.out;

      group assert_val {
          is_arvalid.in = 1'b1;
          is_arvalid.write_en = 1'b1;
          assert_val[done] = is_arvalid.done;
      }
      
      group deassert_val {
          is_arvalid.in = 1'b0;
          is_arvalid.write_en = 1'b1;
          deassert_val[done] = is_arvalid.done;
      }

      group block_transfer{
          block_transfer_done_and.left = ARREADY;
          block_transfer_done_and.right = is_arvalid.out;
          bt_reg.in = block_transfer_done_and.out;
          bt_reg.write_en = 1'b1;
          block_transfer[done] = bt_reg.out;
      }

      group reset_bt {
          bt_reg.in = 1'b0;
          bt_reg.write_en = 1'b1;
          reset_bt[done] = bt_reg.done;
      }

      group do_ar_transfer {
          ARADDR = base_addr.out;
          ARSIZE = 3'b110; //see link above, needs to match data width to host.
          //For now this can be taken from .yxi, as size of mem.
          //If we want to use bigger mems need to be able to update base addr and
          //make multiple calls.
          ARLEN = txn_len.out;
          ARBURST = 2'b01; //incr
          //TODO(natahnielnrn) is this okay? Will this keep everything high for a single cycle?
          do_ar_transfer[done] = ARREADY;
      }


      //txn bookkeeping.
      //We are done performing reads when txn_count == txn_n
      group txn_count_init {
          txn_count.in = 32'b0;
          txn_count.write_en = 1'b1;
          txn_count_init[done] = txn_count.done;
          
      }

      group txn_len_init {
          //for txn_ln, make it 16 (dot product has 16 elements). Length is ARLEN + 1
          txn_len.in = 8'd15;
          txn_len.write_en = 1'b1;
          txn_len_init[done] = txn_len.done;
      }

      group txn_incr {
          txn_adder.left = txn_count.out;
          txn_adder.right = 32'b1;
          txn_count.in = txn_adder.out;
          txn_count.write_en = 1'b1;
          txn_incr[done] = txn_count.done;

      }

      comb group check_reads_done {
          perform_reads.left = txn_count.out;
          perform_reads.right = txn_n.out;
      }
  }

  control{
      //probably for now just want a counter and done of m_read_channel_check.
      //Question: Is there a way offering more flexibility than just a counter?
      seq{
          txn_count_init;
          txn_len_init;
          while perform_reads.out with check_reads_done{
              seq{
                  reset_bt;
                  assert_val;
                  block_transfer;
                  do_ar_transfer;
                  deassert_val;
                  txn_incr;
              }
          }
      }
  }
}




component m_read_channel(
  ARESET : 1,
  RVALID : 1,
  RLAST  : 1,
  RDATA  : 512, //TODO(nathanielnrn): figure out where we want to shrink to 32
  RRESP :  2,  //Note: This is generated in subordinate! had this backwards in earlier version
) -> (
  RREADY : 1,
) {
  cells {
      //16 is due to dot-product vector length assumption
      ref data_received = seq_mem_d1(32, 16, 64);
      is_rdy = std_reg(1);
      ref curr_addr = std_reg(64); //TODO(nathanielnrn): not used in axi, only internal
      
      n_RLAST = std_not(1);


      //TODO(nathanielnrn): This is a hack to allow things to compile with bit widths.
      //Still need to figure out how we actually want to be shrinking from 512 to 32
      //NOTE: this takes [31:0] by definition
      rdata_slice = std_slice(512,32);



      block_transfer_done_and = std_and(1);
      bt_reg = std_reg(1);

  }
  wires{

      RREADY = is_rdy.out;
      data_received.read_en = 1'b0;
      comb group not_rlast{
          n_RLAST.in = RLAST;
      }

      //note RREADY must be registered.
      //Want this to always be running for life of program. So how do we determine doneness?
      //This should want to look at done signal of entire program, which will depend on this group being done.
      //Don't think we can just wrap this as a top level par block for that reason.

      group assert_rdy{
          is_rdy.in = 1'b1;
          is_rdy.write_en = 1'b1;
          assert_rdy[done] = is_rdy.done;
      }

      group deassert_rdy{
          is_rdy.in = 1'b0;
          is_rdy.write_en = 1'b1;
          deassert_rdy[done] = is_rdy.done;
      }

      group reset_bt {
          bt_reg.in = 1'b0;
          bt_reg.write_en = 1'b1;
          reset_bt[done] = bt_reg.done;
      }

      group block_transfer {
        block_transfer_done_and.left = is_rdy.out;
        block_transfer_done_and.right = RVALID;
        bt_reg.in = block_transfer_done_and.out;
        bt_reg.write_en = 1'b1;
        block_transfer[done] = bt_reg.out;
        //block_transfer[done] = !(is_rdy.out & RVALID) ? 1'b0; //good to be explicit and not rely on undefined behavior
      }

      group receive_r_transfer{
          //TODO(nathanielnrn): get addr from register in ARCHANNEL?
          data_received.addr0 = curr_addr.out;
          data_received.write_en = 1'b1;
          rdata_slice.in = RDATA;
          data_received.write_data = rdata_slice.out;
          receive_r_transfer[done] = data_received.write_done;
      }
  }
  control{
      //XXX(nathanielnrn): is this it? Do we need any other conditions?
      while n_RLAST.out with not_rlast{
          seq{
              reset_bt;
              assert_rdy;
              block_transfer;
              deassert_rdy;
              receive_r_transfer;
          }
      }
  }
}

//TODO(nathanielnrn): this is axi_wrapper, prefer to use @toplevel attribute but its not working
component main(
    m_ARESET : 1,
    m_ARREADY : 1,

    m_RVALID : 1,
    m_RLAST : 1,
    m_RDATA : 512,
    m_RRESP : 2,
    //NOTE: Only used for cocotb compatability, doesn't do anything within the wrapper itself currently.
    m_RID : 1,
) -> (
    m_ARVALID : 1,
    //This needs to be 64, see link below `m_axi` section.
    m_ARADDR: 64,
    //2^ARSIZE is bytes used in transfer. For memory-mapped AXI (which is what we
    //are doing I believe), should match width of data bus (to shell?, so 512 wide?
    //which is 3'b110?)
    //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
    // for restrictions
    m_ARSIZE: 3,

    m_ARLEN : 8, //in AXI4 this is 8 bits, 1-256 transfers in requested transaction.

   // 00 for fixed, 01 for incrementing, 2 for wrap, needs to be incr
    m_ARBURST : 2,
    m_RREADY : 1,
    //NOTE: Only used for cocotb compatability, doesn't do anything within the wrapper itself currently.
    m_ARID : 1
) {
    cells{
        vec1_data = seq_mem_d1(32,16,64);
        // Not used currently
        //vec2_data = seq_mem_d1(32,16,4); 
        output_data = seq_mem_d1(32,1,0);

        curr_addr = std_reg(64); //TODO(nathanielnrn): figure out where this comes from, see generated toplevel and kernel interface requirements below.
        base_addr = std_reg(64);

        read_channel = m_read_channel();
        arread_channel = m_arread_channel();

    }

    wires{

        m_ARID = 1'b0;

        group set_curr_to_base_addr{
            curr_addr.in = base_addr.out;
            curr_addr.write_en = 1'b1;
            set_curr_to_base_addr[done] = curr_addr.done;
        }
    }

    control{
        seq{
            //TODO(nathanielnrn): find out what inputs we need to hook up to properly interface. Can probably see here:
            //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
            //and also base off of https://github.com/cucapra/calyx/blob/master/tests/xilinx/gen-verilog/dot-product.expect
            //which probably works? Needs to be tested
            invoke arread_channel[base_addr = base_addr]
            (
            ARESET = m_ARESET,
            ARREADY = m_ARREADY
            )
            (
            ARVALID = m_ARVALID,
            ARADDR = m_ARADDR,
            ARSIZE = m_ARSIZE,
            ARLEN = m_ARLEN,
            ARBURST = m_ARBURST
            );
            set_curr_to_base_addr;
            invoke read_channel[data_received = vec1_data, curr_addr = curr_addr]
            (
            ARESET = m_ARESET,
            RVALID = m_RVALID,
            RLAST = m_RLAST,
            RDATA = m_RDATA,
            RRESP = m_RRESP
            )
            (
            RREADY = m_RREADY
            );
        }
    }


}
