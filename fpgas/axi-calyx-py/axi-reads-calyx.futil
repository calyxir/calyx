// ###
// This file contains the components needed to perform read transacitons via AXI.
// Current goal is to create a cocotb testbench that tests correctness of this.
// See https://github.com/cucapra/calyx/issues/1733 for more information.
//
// This wrapper assumes it is part of a dot product computation with vectors of
// length 16
// This is largely a work in progress and as of Nov 20 2023 is not intended to
// actually be used for anything
// ###




//this goes m->s unlike read channel
component m_arread_channel(
  ARESET: 1,
  ARREADY: 1,
) -> (
  ARVALID: 1,
  //This needs to be 64, see link below `m_axi` section.
  ARADDR: 64,
  //2^ARSIZE is bytes used in transfer. For memory-mapped AXI (which is what we
  //are doing I believe), should match width of data bus (to shell?, so 512 wide?
  //which is 3'b110?)
  //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
  // for restrictions
  ARSIZE: 3,

  ARLEN : 8, //in AXI4 this is 8 bits, 1-256 transfers in requested transaction.
  
  // 00 for fixed, 01 for incrementing, 2 for wrap, needs to be incr)
  ARBURST : 2
) {
  cells{
      is_arvalid = std_reg(1);
      //todo(nathanielnrn): we get this from `s_axi_control`. Need to check 
      //how we known actual address
      //should probably live in `s_axi_control` but for now will live here
      ref base_addr = std_reg(64);
      //also need to figure out how to calculate this. Prob from yxi.
      transaction_len = std_reg(8);

  }

  wires{

      group assert_val {
          is_arvalid.in = 1'b1;
          is_arvalid_write_en = 1'b1;
          assert_valid[done = is_arvalid.done;
      }
      
      group deassert_val {
          is_arvalid.in = 1'b0;
          is_arvalid_write_en = 1'b1;
          assert_valid[done = is_arvalid.done;
      }

      group block_transfer{
          block_transfer[done] = ARREADY && ARVALID ? 1'b1;
          block_transfer[done] = !(ARREADY && ARVALID) ? 1'b0;
      }

      group do_ar_transfer {
          ARADDR = base_addr.out;
          ARSIZE = 3'b110; //see link above, needs to match data width to host.
          //For now this can be taken from .yxi, as size of mem.
          //If we want to use bigger mems need to be able to update base addr and
          //make multiple calls.
          ARLEN = transaction_len.out
          ARBURST = 2'b01; //incr
      }
  }

  control{
      //perform_reads.out = TODO(nathanielnrn): figure out where this comes from.
      //Should be high while FSM still has reads to do && done with previous read request
      //probably for now just want a counter and done of m_read_channel_check.
      //Question: Is there a way offering more flexibility than just a counter?
      while perform_reads.out{ //TODO(nathanielnrn): create this
          seq {
              assert_val;
              block_transfer;
              deassert_val;
              do_ar_transfer;
          }
      }
  }
}




component m_read_channel(
  ARESET : 1,
  RVALID : 1,
  RLAST  : 1,
  RDATA  : 512, //TODO(nathanielnrn): figure out where we want to shrink to 32
  RRESP :  2,  //Note: This is generated in subordinate! had this backwards in earlier version
) -> (
  RREADY : 1,
) {
  cells {
      //16 is due to dot-product vector length assumption
      ref data_received = seq_mem_d1(32, 16, 4);
      is_rdy = std_reg(1);
      ref curr_addr = std_reg(64); //TODO(nathanielnrn): not used in axi, only internal



      //needed solely for with reg_rdy_en comb group
      //TODO(nathanielnrn): Do we need this?
      //mem_done_or = std_or(1);
      //mem_en_or = std_or(1);

  }
  wires{

      RREADY = is_rdy.out;

      //note RREADY must be registered.
      //Want this to always be running for life of program. So how do we determine doneness?
      //This should want to look at done signal of entire program, which will depend on this group being done.
      //Don't think we can just wrap this as a top level par block for that reason.

      group assert_rdy{
          is_rdy.in = 1'b1;
          is_rdy.write_en = 1'b1;
          assert_rdy[done] = is_rdy.done;
      }

      group deassert_rdy{
          is_rdy.in = 1'b0;
          is_rdy.write_en = 1'b1;
          deassert_rdy[done] = is_rdy.done;
      }

      group block_transfer {
        block_transfer[done] = RREADY && RVALID ? 1'b1;
        block_transfer[done] = !(RREADY && RVALID) ? 1'b0; //good to be explicit and not rely on undefined behavior
      }

      group receive_r_transfer{
          //TODO(nathanielnrn): get addr from register in ARCHANNEL?
          data_received.addr0 = curr_addr.out;
          data_received.write_en = 1'b1;
          data_received.in = RDATA;
          receive_r_transfer[done] = data_received.done;
      }
  }
  control{
      //XXX(nathanielnrn): is this it? Do we need any other conditions?
      while !RLAST {
          seq{
              assert_rdy;
              block_transfer;
              deassert_rdy;
              do_transfer;
          }
      }
  }



component axi_wrapper(
    ARESET : 1,
    ARREADY : 1,

    RVALID : 1,
    RLAST : 1,
    RDATA : 512,
    RRESP : 2,
) -> (
    ARVALID : 1,
    //This needs to be 64, see link below `m_axi` section.
    ARADDR: 64,
    //2^ARSIZE is bytes used in transfer. For memory-mapped AXI (which is what we
    //are doing I believe), should match width of data bus (to shell?, so 512 wide?
    //which is 3'b110?)
    //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
   // for restrictions
   ARSIZE: 3,

   ARLEN : 8, //in AXI4 this is 8 bits, 1-256 transfers in requested transaction.

   // 00 for fixed, 01 for incrementing, 2 for wrap, needs to be incr
   ARBURST : 2

   RREADY : 1
) {
    cells{
        vec1_data = seq_mem_d1(32,16,4);
        // Not used currently
        //vec2_data = seq_mem_d1(32,16,4); 
        output_data = seq_mem_d1(32,1,0);

        curr_addr = std_reg(64); //TODO(nathanielnrn): figure out where this comes from, see generated toplevel and kernel interface requirements below.
        base_addr = std_reg(64);

        read_channel = m_read_channel();
        arread_channel = m_arread_channel();

    }

    wires{

        group set_curr_to_base_addr{
            curr_addr.in = base_addr.out;
            curr_addr.write_en = 1'b1;
            set_curr_to_base_addr[done] = curr_addr.done;
        }
    }

    control{
        seq{
            //TODO(nathanielnrn): find out what inputs we need to hook up to properly interface. Can probably see here:
            //see https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
            //and also base off of https://github.com/cucapra/calyx/blob/master/tests/xilinx/gen-verilog/dot-product.expect
            //which probably works? Needs to be tested
            invoke arread_channel[base_addr = base_addr]
            (
            ARRESET = ARRESET,
            ARREADY = ARREADY
            )
            (
            ARVALID = ARVALID,
            ARADDR = ARADDR,
            ARSIZE = ARSIZE,
            ARLEN = ARLEN,
            ARBUST = ARBURST
            );
            set_curr_to_base_addr;
            invoke read_channel[data_received = vec1_data, curr_addr = curr_addr]
            (
            ARESET = ARESET,
            RVALID = RVALID,
            RLAST = RLAST,
            RDATA = RDATA,
            RRESP = RRESP
            )
            (
            RREADY = RREADY
            );
        }
    }


}
