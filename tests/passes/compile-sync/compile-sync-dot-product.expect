import "primitives/core.futil";
import "primitives/sync.futil";
import "primitives/binary_operators.futil";
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external in_0 = std_mem_d1(32, 18, 32);
    @external in_1 = std_mem_d1(32, 18, 32);
    @external out = std_mem_d1(32, 1, 32);
    idx_0 = std_reg(32);
    idx_1 = std_reg(32);
    point_0 = std_reg(32);
    point_1 = std_reg(32);
    val_0 = std_reg(32);
    val_1 = std_reg(32);
    val_out = std_reg(32);
    lt_0 = std_lt(32);
    lt_1 = std_lt(32);
    incr_0 = std_add(32);
    incr_1 = std_add(32);
    add = std_add(32);
    mult = std_smult_pipe(32);
    fwd_0 = std_lt(32);
    fwd_1 = std_lt(32);
    eq = std_eq(1);
    signal = std_or(1);
    no_use_0 = std_reg(1);
    no_use_1 = std_reg(1);
    flag = std_reg(1);
    flag_reg = std_reg(1);
    sign = std_reg(1);
    eq0 = std_eq(1);
    eq1 = std_eq(32);
    no_use = std_reg(1);
    @generated barrier = std_sync_reg(32);
    @generated eq00 = std_eq(32);
    @generated wait_restore_reg = std_reg(1);
    @generated save = std_reg(32);
    @generated incr = std_add(32);
    @generated wait_reg = std_reg(1);
    @generated save0 = std_reg(32);
    @generated incr0 = std_add(32);
    @generated wait_reg0 = std_reg(1);
    @generated barrier0 = std_sync_reg(32);
    @generated eq10 = std_eq(32);
    @generated wait_restore_reg0 = std_reg(1);
    @generated save1 = std_reg(32);
    @generated incr1 = std_add(32);
    @generated wait_reg1 = std_reg(1);
    @generated save2 = std_reg(32);
    @generated incr2 = std_add(32);
    @generated wait_reg2 = std_reg(1);
    @generated save3 = std_reg(32);
    @generated incr3 = std_add(32);
    @generated wait_reg3 = std_reg(1);
  }
  wires {
    group no_op {
      no_use.write_en = 1'd1;
      no_use.in = 1'd1;
      no_op[done] = no_use.done;
    }
    group initialize_idx {
      idx_1.write_en = 1'd1;
      in_1.addr0 = 32'd0;
      idx_1.in = in_1.read_data;
      idx_0.write_en = 1'd1;
      in_0.addr0 = 32'd0;
      idx_0.in = in_0.read_data;
      initialize_idx[done] = idx_0.done & idx_1.done ? 1'd1;
    }
    group initialize_val {
      val_1.write_en = 1'd1;
      in_1.addr0 = 32'd1;
      val_1.in = in_1.read_data;
      val_0.write_en = 1'd1;
      in_0.addr0 = 32'd1;
      val_0.in = in_0.read_data;
      initialize_val[done] = val_0.done & val_1.done ? 1'd1;
    }
    group fwd_idx_0 {
      idx_0.write_en = 1'd1;
      in_0.addr0 = point_0.out;
      idx_0.in = in_0.read_data;
      fwd_idx_0[done] = idx_0.done;
    }
    group fwd_idx_1 {
      idx_1.write_en = 1'd1;
      in_1.addr0 = point_1.out;
      idx_1.in = in_1.read_data;
      fwd_idx_1[done] = idx_1.done;
    }
    group forward_pointer_0 {
      point_0.write_en = 1'd1;
      incr_0.right = point_0.out;
      incr_0.left = 32'd2;
      point_0.in = incr_0.out;
      forward_pointer_0[done] = point_0.done;
    }
    group forward_pointer_1 {
      point_1.write_en = 1'd1;
      incr_1.right = point_1.out;
      incr_1.left = 32'd2;
      point_1.in = incr_1.out;
      forward_pointer_1[done] = point_1.done;
    }
    group val_to_reg_0 {
      val_0.write_en = 1'd1;
      incr_0.right = point_0.out;
      incr_0.left = 32'd1;
      in_0.addr0 = incr_0.out;
      val_0.in = in_0.read_data;
      val_to_reg_0[done] = val_0.done;
    }
    group val_to_reg_1 {
      val_1.write_en = 1'd1;
      incr_1.right = point_1.out;
      incr_1.left = 32'd1;
      in_1.addr0 = incr_1.out;
      val_1.in = in_1.read_data;
      val_to_reg_1[done] = val_1.done;
    }
    group compute_product {
      val_out.write_en = mult.done ? 1'd1;
      val_out.in = mult.done ? mult.out;
      mult.right = val_1.out;
      mult.left = val_0.out;
      mult.go = 1'd1;
      compute_product[done] = val_out.done;
    }
    group add_to_out {
      out.write_en = 1'd1;
      add.right = val_out.out;
      out.addr0 = 32'd0;
      add.left = out.read_data;
      out.write_data = add.out;
      add_to_out[done] = out.done;
    }
    group restore {
      barrier.write_en_0 = 1'd1;
      barrier.in_0 = 32'd0;
      restore[done] = barrier.write_done_0;
    }
    group wait_restore {
      wait_restore_reg.in = !eq00.out ? 1'd1;
      wait_restore_reg.write_en = !eq00.out ? 1'd1;
      wait_restore[done] = wait_restore_reg.done;
    }
    group clear_barrier {
      barrier.read_en_0 = 1'd1;
      clear_barrier[done] = barrier.read_done_0;
    }
    group incr_barrier {
      barrier.read_en_0 = 1'd1;
      incr.left = barrier.out_0;
      incr.right = 32'd1;
      save.in = barrier.read_done_0 ? incr.out;
      save.write_en = barrier.read_done_0;
      incr_barrier[done] = save.done;
    }
    group write_barrier {
      barrier.write_en_0 = 1'd1;
      barrier.in_0 = save.out;
      write_barrier[done] = barrier.write_done_0;
    }
    group wait {
      wait_reg.in = eq00.out;
      wait_reg.write_en = eq00.out ? 1'd1;
      wait[done] = wait_reg.done;
    }
    group incr_barrier0 {
      barrier.read_en_0 = 1'd1;
      incr0.left = barrier.out_0;
      incr0.right = 32'd1;
      save0.in = barrier.read_done_0 ? incr0.out;
      save0.write_en = barrier.read_done_0;
      incr_barrier0[done] = save0.done;
    }
    group write_barrier0 {
      barrier.write_en_0 = 1'd1;
      barrier.in_0 = save0.out;
      write_barrier0[done] = barrier.write_done_0;
    }
    group wait0 {
      wait_reg0.in = eq00.out;
      wait_reg0.write_en = eq00.out ? 1'd1;
      wait0[done] = wait_reg0.done;
    }
    group restore0 {
      barrier0.write_en_0 = 1'd1;
      barrier0.in_0 = 32'd0;
      restore0[done] = barrier0.write_done_0;
    }
    group wait_restore0 {
      wait_restore_reg0.in = !eq10.out ? 1'd1;
      wait_restore_reg0.write_en = !eq10.out ? 1'd1;
      wait_restore0[done] = wait_restore_reg0.done;
    }
    group clear_barrier0 {
      barrier0.read_en_0 = 1'd1;
      clear_barrier0[done] = barrier0.read_done_0;
    }
    group incr_barrier1 {
      barrier0.read_en_0 = 1'd1;
      incr1.left = barrier0.out_0;
      incr1.right = 32'd1;
      save1.in = barrier0.read_done_0 ? incr1.out;
      save1.write_en = barrier0.read_done_0;
      incr_barrier1[done] = save1.done;
    }
    group write_barrier1 {
      barrier0.write_en_0 = 1'd1;
      barrier0.in_0 = save1.out;
      write_barrier1[done] = barrier0.write_done_0;
    }
    group wait1 {
      wait_reg1.in = eq10.out;
      wait_reg1.write_en = eq10.out ? 1'd1;
      wait1[done] = wait_reg1.done;
    }
    group incr_barrier2 {
      barrier0.read_en_1 = 1'd1;
      incr2.left = barrier0.out_1;
      incr2.right = 32'd1;
      save2.in = barrier0.read_done_1 ? incr2.out;
      save2.write_en = barrier0.read_done_1;
      incr_barrier2[done] = save2.done;
    }
    group write_barrier2 {
      barrier0.write_en_1 = 1'd1;
      barrier0.in_1 = save2.out;
      write_barrier2[done] = barrier0.write_done_1;
    }
    group wait2 {
      wait_reg2.in = eq10.out;
      wait_reg2.write_en = eq10.out ? 1'd1;
      wait2[done] = wait_reg2.done;
    }
    group incr_barrier3 {
      barrier.read_en_1 = 1'd1;
      incr3.left = barrier.out_1;
      incr3.right = 32'd1;
      save3.in = barrier.read_done_1 ? incr3.out;
      save3.write_en = barrier.read_done_1;
      incr_barrier3[done] = save3.done;
    }
    group write_barrier3 {
      barrier.write_en_1 = 1'd1;
      barrier.in_1 = save3.out;
      write_barrier3[done] = barrier.write_done_1;
    }
    group wait3 {
      wait_reg3.in = eq00.out;
      wait_reg3.write_en = eq00.out ? 1'd1;
      wait3[done] = wait_reg3.done;
    }
    comb group chase_0 {
      lt_0.right = idx_1.out;
      lt_0.left = idx_0.out;
    }
    comb group chase_1 {
      lt_1.right = idx_0.out;
      lt_1.left = idx_1.out;
    }
    comb group equal {
      eq1.right = idx_0.out;
      eq1.left = idx_1.out;
    }
    comb group comp {
      fwd_1.right = 32'd16;
      fwd_1.left = idx_1.out;
      signal.right = fwd_1.out;
      fwd_0.right = 32'd16;
      fwd_0.left = idx_0.out;
      signal.left = fwd_0.out;
    }
    eq00.left = barrier.peek;
    eq00.right = 32'd2;
    eq10.left = barrier0.peek;
    eq10.right = 32'd2;
  }

  control {
    seq {
      initialize_idx;
      initialize_val;
      seq {
        par {
          restore;
          restore0;
        }
        par {
          while signal.out with comp {
            if lt_0.out with chase_0 {
              seq {
                while lt_0.out with chase_0 {
                  seq {
                    fwd_idx_0;
                    forward_pointer_0;
                  }
                }
                seq {
                  val_to_reg_0;
                  incr_barrier;
                  write_barrier;
                  wait;
                  clear_barrier;
                  restore;
                }
              }
            } else {
              if eq1.out with equal {
                seq {
                  compute_product;
                  add_to_out;
                  fwd_idx_0;
                  seq {
                    forward_pointer_0;
                    incr_barrier0;
                    write_barrier0;
                    wait0;
                    clear_barrier;
                    restore;
                  }
                }
              } else {
                seq {
                  seq {
                    no_op;
                    incr_barrier1;
                    write_barrier1;
                    wait1;
                    clear_barrier0;
                    restore0;
                  }
                }
              }
            }
          }
          while signal.out with comp {
            if lt_1.out with chase_1 {
              seq {
                while lt_1.out with chase_1 {
                  seq {
                    fwd_idx_1;
                    forward_pointer_1;
                  }
                }
                seq {
                  val_to_reg_1;
                  incr_barrier2;
                  write_barrier2;
                  wait2;
                  wait_restore0;
                }
              }
            } else {
              seq {
                seq {
                  no_op;
                  incr_barrier3;
                  write_barrier3;
                  wait3;
                  wait_restore;
                }
              }
            }
          }
        }
      }
      compute_product;
      add_to_out;
    }
  }
}
