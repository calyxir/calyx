import "primitives/core.futil";
import "primitives/sync.futil";
import "primitives/binary_operators.futil";
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external in_0 = std_mem_d1(32, 18, 32);
    @external in_1 = std_mem_d1(32, 18, 32);
    @external out = std_mem_d1(32, 1, 32);
    idx_0 = std_reg(32);
    idx_1 = std_reg(32);
    point_0 = std_reg(32);
    point_1 = std_reg(32);
    val_0 = std_reg(32);
    val_1 = std_reg(32);
    val_out = std_reg(32);
    lt_0 = std_lt(32);
    lt_1 = std_lt(32);
    incr_0 = std_add(32);
    incr_1 = std_add(32);
    add = std_add(32);
    mult = std_smult_pipe(32);
    fwd_0 = std_lt(32);
    fwd_1 = std_lt(32);
    eq = std_eq(1);
    signal = std_or(1);
    no_use_0 = std_reg(1);
    no_use_1 = std_reg(1);
    flag = std_reg(1);
    flag_reg = std_reg(1);
    sign = std_reg(1);
    eq0 = std_eq(1);
    @generated barrier = std_sync_reg(32);
    @generated eq00 = std_eq(32);
    @generated wait_restore_reg = std_reg(1);
    @generated save = std_reg(32);
    @generated incr = std_add(32);
    @generated wait_reg = std_reg(1);
    @generated save0 = std_reg(32);
    @generated incr0 = std_add(32);
    @generated wait_reg0 = std_reg(1);
    @generated save1 = std_reg(32);
    @generated incr1 = std_add(32);
    @generated wait_reg1 = std_reg(1);
  }
  wires {
    group sign_compute {
      sign.write_en = 1'd1;
      sign.in = 1'd1;
      sign_compute[done] = sign.done;
    }
    group sign_complete {
      sign.write_en = 1'd1;
      sign.in = 1'd0;
      sign_complete[done] = sign.done;
    }
    group signal_compute {
      flag.write_en = 1'd1;
      flag.in = 1'd1;
      signal_compute[done] = flag.done;
    }
    group signal_complete {
      flag.write_en = 1'd1;
      flag.in = 1'd0;
      signal_complete[done] = flag.done;
    }
    group wait_compute {
      flag_reg.write_en = flag.out ? 1'd1;
      flag_reg.in = 1'd1;
      wait_compute[done] = flag_reg.done;
    }
    group initialize_idx {
      idx_1.write_en = 1'd1;
      in_1.addr0 = 32'd0;
      idx_1.in = in_1.read_data;
      idx_0.write_en = 1'd1;
      in_0.addr0 = 32'd0;
      idx_0.in = in_0.read_data;
      initialize_idx[done] = idx_0.done & idx_1.done ? 1'd1;
    }
    group initialize_val {
      val_1.write_en = 1'd1;
      in_1.addr0 = 32'd1;
      val_1.in = in_1.read_data;
      val_0.write_en = 1'd1;
      in_0.addr0 = 32'd1;
      val_0.in = in_0.read_data;
      initialize_val[done] = val_0.done & val_1.done ? 1'd1;
    }
    group fwd_idx_0 {
      idx_0.write_en = 1'd1;
      in_0.addr0 = point_0.out;
      idx_0.in = in_0.read_data;
      fwd_idx_0[done] = idx_0.done;
    }
    group fwd_idx_1 {
      idx_1.write_en = 1'd1;
      in_1.addr0 = point_1.out;
      idx_1.in = in_1.read_data;
      fwd_idx_1[done] = idx_1.done;
    }
    group forward_pointer_0 {
      point_0.write_en = 1'd1;
      incr_0.right = point_0.out;
      incr_0.left = 32'd2;
      point_0.in = incr_0.out;
      forward_pointer_0[done] = point_0.done;
    }
    group forward_pointer_1 {
      point_1.write_en = 1'd1;
      incr_1.right = point_1.out;
      incr_1.left = 32'd2;
      point_1.in = incr_1.out;
      forward_pointer_1[done] = point_1.done;
    }
    group val_to_reg_0 {
      val_0.write_en = 1'd1;
      incr_0.right = point_0.out;
      incr_0.left = 32'd1;
      in_0.addr0 = incr_0.out;
      val_0.in = in_0.read_data;
      val_to_reg_0[done] = val_0.done;
    }
    group val_to_reg_1 {
      val_1.write_en = 1'd1;
      incr_1.right = point_1.out;
      incr_1.left = 32'd1;
      in_1.addr0 = incr_1.out;
      val_1.in = in_1.read_data;
      val_to_reg_1[done] = val_1.done;
    }
    group compute_product {
      val_out.write_en = mult.done ? 1'd1;
      val_out.in = mult.done ? mult.out;
      mult.right = val_1.out;
      mult.left = val_0.out;
      mult.go = 1'd1;
      compute_product[done] = val_out.done;
    }
    group add_to_out {
      out.write_en = 1'd1;
      add.right = val_out.out;
      out.addr0 = 32'd0;
      add.left = out.read_data;
      out.write_data = add.out;
      add_to_out[done] = out.done;
    }
    group restore {
      barrier.write_en_0 = 1'd1;
      barrier.in_0 = 32'd0;
      restore[done] = barrier.write_done_0;
    }
    group wait_restore {
      wait_restore_reg.in = !eq00.out ? 1'd1;
      wait_restore_reg.write_en = !eq00.out ? 1'd1;
      wait_restore[done] = wait_restore_reg.done;
    }
    group clear_barrier {
      barrier.read_en_0 = 1'd1;
      clear_barrier[done] = barrier.read_done_0;
    }
    group incr_barrier {
      barrier.read_en_0 = 1'd1;
      incr.left = barrier.out_0;
      incr.right = 32'd1;
      save.in = barrier.read_done_0 ? incr.out;
      save.write_en = barrier.read_done_0;
      incr_barrier[done] = save.done;
    }
    group write_barrier {
      barrier.write_en_0 = 1'd1;
      barrier.in_0 = save.out;
      write_barrier[done] = barrier.write_done_0;
    }
    group wait {
      wait_reg.in = eq00.out;
      wait_reg.write_en = eq00.out ? 1'd1;
      wait[done] = wait_reg.done;
    }
    group incr_barrier0 {
      barrier.read_en_0 = 1'd1;
      incr0.left = barrier.out_0;
      incr0.right = 32'd1;
      save0.in = barrier.read_done_0 ? incr0.out;
      save0.write_en = barrier.read_done_0;
      incr_barrier0[done] = save0.done;
    }
    group write_barrier0 {
      barrier.write_en_0 = 1'd1;
      barrier.in_0 = save0.out;
      write_barrier0[done] = barrier.write_done_0;
    }
    group wait0 {
      wait_reg0.in = eq00.out;
      wait_reg0.write_en = eq00.out ? 1'd1;
      wait0[done] = wait_reg0.done;
    }
    group incr_barrier1 {
      barrier.read_en_1 = 1'd1;
      incr1.left = barrier.out_1;
      incr1.right = 32'd1;
      save1.in = barrier.read_done_1 ? incr1.out;
      save1.write_en = barrier.read_done_1;
      incr_barrier1[done] = save1.done;
    }
    group write_barrier1 {
      barrier.write_en_1 = 1'd1;
      barrier.in_1 = save1.out;
      write_barrier1[done] = barrier.write_done_1;
    }
    group wait1 {
      wait_reg1.in = eq00.out;
      wait_reg1.write_en = eq00.out ? 1'd1;
      wait1[done] = wait_reg1.done;
    }
    comb group in_barrier {
      eq0.right = 1'd1;
      eq0.left = sign.out;
    }
    comb group has_computing_job {
      eq.right = 1'd1;
      eq.left = flag.out;
    }
    comb group chase_0 {
      lt_0.right = idx_1.out;
      lt_0.left = idx_0.out;
    }
    comb group chase_1 {
      lt_1.right = idx_0.out;
      lt_1.left = idx_1.out;
    }
    comb group comp {
      fwd_1.right = 32'd16;
      fwd_1.left = idx_1.out;
      signal.right = fwd_1.out;
      fwd_0.right = 32'd16;
      fwd_0.left = idx_0.out;
      signal.left = fwd_0.out;
    }
    eq00.left = barrier.peek;
    eq00.right = 32'd2;
  }

  control {
    seq {
      initialize_idx;
      initialize_val;
      seq {
        par {
          restore;
        }
        par {
          while signal.out with comp {
            if lt_0.out with chase_0 {
              seq {
                while lt_0.out with chase_0 {
                  seq {
                    forward_pointer_0;
                    fwd_idx_0;
                  }
                }
                val_to_reg_0;
                if eq0.out with in_barrier {
                  seq {
                    seq {
                      sign_complete;
                      incr_barrier;
                      write_barrier;
                      wait;
                      clear_barrier;
                      restore;
                    }
                  }
                }
              }
            } else {
              if lt_1.out with chase_1 {
                seq {
                  while lt_1.out with chase_1 {
                    seq {
                      forward_pointer_1;
                      fwd_idx_1;
                    }
                  }
                  val_to_reg_1;
                  if eq0.out with in_barrier {
                    seq {
                      seq {
                        sign_complete;
                        incr_barrier0;
                        write_barrier0;
                        wait0;
                        clear_barrier;
                        restore;
                      }
                    }
                  }
                }
              } else {
                seq {
                  signal_compute;
                  sign_compute;
                  forward_pointer_0;
                  fwd_idx_0;
                  val_to_reg_0;
                }
              }
            }
          }
          while signal.out with comp {
            if eq.out with has_computing_job {
              seq {
                compute_product;
                add_to_out;
                seq {
                  signal_complete;
                  incr_barrier1;
                  write_barrier1;
                  wait1;
                  wait_restore;
                }
              }
            } else {
              seq {
                wait_compute;
              }
            }
          }
        }
      }
      compute_product;
      add_to_out;
    }
  }
}
