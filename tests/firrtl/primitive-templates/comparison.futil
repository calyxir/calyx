import "primitives/core.futil";
import "primitives/memories/seq.futil";

component main(@go go: 1) -> (@done done: 1) {
  cells {
    @external(1) mem = seq_mem_d2(32, 6, 8, 32, 32);
    loop_guard = std_lt(32);

    gt = std_gt(32);
    ge = std_ge(32);
    lt = std_lt(32);
    le = std_le(32);
    eq = std_eq(32);
    ne = std_neq(32);

    row_reg = std_reg(32);
    const0 = std_const(32, 0);
    const1 = std_const(32, 1);
    add = std_add(32);
    num_rows = std_const(32, 6);

    x = std_reg(32);
    y = std_reg(32);

    column = std_reg(32);
    const2 = std_const(32, 2);

    comp_output = std_reg(32);
    pad = std_pad(1, 32);
  }

  wires {
    comb group cond0 {
      loop_guard.left = row_reg.out;
      loop_guard.right = num_rows.out;
    }
    group init0 {
      row_reg.in = const0.out;
      row_reg.write_en = 1'b1;
      init0[done] = row_reg.done;
    }
    group incr_row {
      add.left = row_reg.out;
      add.right = const1.out;
      row_reg.in = add.out;
      row_reg.write_en = 1'b1;
      incr_row[done] = row_reg.done;
    }

    group load_x {
      mem.addr0 = row_reg.out;
      mem.addr1 = const0.out;
      mem.content_en = 1'b1;
      x.in = mem.read_data;
      x.write_en = mem.done ? 1'b1;
      load_x[done] = x.done;
    }

    group load_y {
      mem.addr0 = row_reg.out;
      mem.addr1 = const1.out;
      mem.content_en = 1'b1;
      y.in = mem.read_data;
      y.write_en = mem.done ? 1'b1;
      load_y[done] = y.done;
    }

    group start_column {
      column.in = const2.out;
      column.write_en = 1'b1;
      start_column[done] = column.done;
    }

    group incr_column {
      add.left = column.out;
      add.right = const1.out;
      column.in = add.out;
      column.write_en = 1'b1;
      incr_column[done] = column.done;
    }

    group gt_compare {
      gt.left = x.out;
      gt.right = y.out;
      pad.in = gt.out;
      comp_output.in = pad.out;
      comp_output.write_en = 1'b1;
      gt_compare[done] = comp_output.done;
    }

    group ge_compare {
      ge.left = x.out;
      ge.right = y.out;
      pad.in = ge.out;
      comp_output.in = pad.out;
      comp_output.write_en = 1'b1;
      ge_compare[done] = comp_output.done;
    }

    group lt_compare {
      lt.left = x.out;
      lt.right = y.out;
      pad.in = lt.out;
      comp_output.in = pad.out;
      comp_output.write_en = 1'b1;
      lt_compare[done] = comp_output.done;
    }

    group le_compare {
      le.left = x.out;
      le.right = y.out;
      pad.in = le.out;
      comp_output.in = pad.out;
      comp_output.write_en = 1'b1;
      le_compare[done] = comp_output.done;
    }

    group eq_compare {
      eq.left = x.out;
      eq.right = y.out;
      pad.in = eq.out;
      comp_output.in = pad.out;
      comp_output.write_en = 1'b1;
      eq_compare[done] = comp_output.done;
    }

    group ne_compare {
      ne.left = x.out;
      ne.right = y.out;
      pad.in = ne.out;
      comp_output.in = pad.out;
      comp_output.write_en = 1'b1;
      ne_compare[done] = comp_output.done;
    }

    group write_result {
      mem.addr0 = row_reg.out;
      mem.addr1 = column.out;
      mem.content_en = 1'b1;
      mem.write_data = comp_output.out;
      mem.write_en = 1'b1;
      write_result[done] = mem.done;
    }
  }

  control {
    seq {
      init0;
      while loop_guard.out with cond0 {
        seq {
          load_x;
          load_y;

          start_column;
          
          gt_compare;
          write_result;
          incr_column;

          ge_compare;
          write_result;
          incr_column;

          lt_compare;
          write_result;
          incr_column;

          le_compare;
          write_result;
          incr_column;

          eq_compare;
          write_result;
          incr_column;

          ne_compare;
          write_result;
          incr_column;

          incr_row;
        }
      }
    }
  }
}