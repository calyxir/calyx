import "primitives/core.futil";
import "primitives/binary_operators.futil";
import "primitives/memories.futil";

component mem_delay_3(write_data: 32, addr0:4, @go(1) read_en: 1, @go(2) write_en: 1) -> (read_data: 32, @done(1) read_done: 1, @done(2) write_done: 1) {
  cells {
    m = seq_mem_d1(32, 3, 4); 
    r1 = std_reg(32);
    r2 = std_reg(32); 
  }
  wires {
    // writes to r1, then r2, then m, but only if writ_en is set high 
    static<3> group write_mem {
      r1.write_en = write_en & %0 ? 1'd1; 
      r1.in = write_en ? write_data; 
      r2.write_en = write_en & %1 ? 1'd1; 
      r2.in = write_en ? r1.out; 
      m.write_en = write_en & %2 ? 1'd1; 
      m.addr0 = write_en ? addr0; 
      m.write_data = write_en ? r2.out; 
    }
    // reads from m, then writes result to r1, then to r2 
    static<3> group read_mem {
      m.addr0 = read_en ? addr0; 
      m.read_en = read_en & %0 ? 1'd1; 
      r1.in = read_en ? m.read_data; 
      r1.write_en = read_en & %1 ? 1'd1; 
      r2.in = read_en ? r1.out;
      r2.write_en = read_en & %2 ? 1'd1; 
    }
    read_data = r2.out; 
  }
  control {
    static par {
      write_mem; 
      read_mem; 
    }
  }
}

component main() -> () {
  cells {
    in1 = mem_delay_3();
    in2 = mem_delay_3();
    @external out = seq_mem_d1(32, 1, 1);

    // Compute primitives
    mult = std_mult_pipe(32);
    add = std_add(32);
    tmp = std_reg(32);

    // Counter
    idx = std_reg(4);
    incr = std_add(4);
    lt = std_lt(4);
  }
  wires {
    comb group is_less_than {
      lt.left = idx.out;
      lt.right = 4'd3;
    }
    static<9> group init_in1 {
      in1.write_en = 1'd1; 
      in1.addr0 = %[0:3] ? 4'd0;
      in1.write_data = %[0:3] ? 32'd3;
      in1.addr0 = %[3:6] ? 4'd1;
      in1.write_data = %[3:6] ? 32'd2;
      in1.addr0 = %[6:9] ? 4'd2;
      in1.write_data = %[6:9] ? 32'd7;
    }
    static<9> group init_in2 {
      in2.write_en = 1'd1; 
      in2.addr0 = %[0:3] ? 4'd0;
      in2.write_data = %[0:3] ? 32'd2;
      in2.addr0 = %[3:6] ? 4'd1;
      in2.write_data = %[3:6] ? 32'd1;
      in2.addr0 = %[6:9] ? 4'd2;
      in2.write_data = %[6:9] ? 32'd5;
    }
    group init_idx {
      idx.in = 4'd0;
      idx.write_en = 1'd1;
      init_idx[done] = idx.done;
    }
    group incr_idx {
      idx.write_en = 1'd1;
      incr.left = idx.out;
      incr.right = 4'd1;
      idx.in = incr.out;
      incr_idx[done] = idx.done;
    }

    // Prime memories for reading
    group prime_in1 {
      in1.read_en = 1'd1;
      in1.addr0 = idx.out;
      prime_in1[done] = in1.read_done;
    }
    group prime_in2 {
      in2.read_en = 1'd1;
      in2.addr0 = idx.out;
      prime_in2[done] = in2.read_done;
    }

    // Computation
    group init_tmp {
      tmp.in = 32'd0;
      tmp.write_en = 1'd1;
      init_tmp[done] = tmp.done;
    }
    group do_add {
      add.left = tmp.out;
      add.right = mult.out;
      tmp.in = add.out;
      tmp.write_en = 1'd1;
      do_add[done] = tmp.done;
    }

    // Write to output
    group write {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = tmp.out;
      write[done] = out.write_done;
    }
  }
  control {
    seq {
      par { init_tmp; init_idx; init_in1; init_in2;}
      while lt.out with is_less_than {
        seq {
          par { prime_in1; prime_in2; }
          invoke mult(left = in1.read_data, right = in2.read_data)();
          par { do_add; incr_idx; }
        }
      }
      write;
    }
  }
}
