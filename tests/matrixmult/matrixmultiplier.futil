import "primitives/core.futil";
import "primitives/pipelined.futil";
import "primitives/memories/comb.futil";

component main(@go go: 1) -> (@done done: 1) {
  cells {
    @external in1_mem = comb_mem_d2(32, 2, 2, 32, 32);
    @external in2_mem = comb_mem_d2(32, 2, 2, 32, 32);
    @external out_mem = comb_mem_d2(32, 2, 2, 32, 32);
    add = std_add(32);
    mult = pipelined_mult(32);
    lt1 = std_lt(32);
    lt2 = std_lt(32);
    lt3 = std_lt(32);
    a_reg = std_reg(32);
    b_reg = std_reg(32);
    i_reg = std_reg(32);
    j_reg = std_reg(32);
    k_reg = std_reg(32);
    sum_reg = std_reg(32);
    mult_reg = std_reg(32);
  }
  wires {
    group incr_i {
      add.left = i_reg.out;
      add.right = 32'd1;
      i_reg.in = add.out;
      i_reg.write_en = 1'b1;
      incr_i[done] = i_reg.done;
    }

    group incr_j {
      add.left = j_reg.out;
      add.right = 32'd1;
      j_reg.in = add.out;
      j_reg.write_en = 1'b1;
      incr_j[done] = j_reg.done;
    }

    group incr_k {
      add.left = k_reg.out;
      add.right = 32'd1;
      k_reg.in = add.out;
      k_reg.write_en = 1'b1;
      incr_k[done] = k_reg.done;
    }

    group load_a {
      in1_mem.addr0 = i_reg.out;
      in1_mem.addr1 = k_reg.out;
      a_reg.in = in1_mem.read_data;
      a_reg.write_en = 1'b1;
      load_a[done] = a_reg.done;
    }

    group load_b {
      in2_mem.addr0 = k_reg.out;
      in2_mem.addr1 = j_reg.out;
      b_reg.in = in2_mem.read_data;
      b_reg.write_en = 1'b1;
      load_b[done] = b_reg.done;
    }

    group reset_i {
      i_reg.in = 32'd0;
      i_reg.write_en = 1'b1;
      reset_i[done] = i_reg.done;
    }

    group reset_j {
      j_reg.in = 32'd0;
      j_reg.write_en = 1'b1;
      reset_j[done] = j_reg.done;
    }

    group reset_k {
      k_reg.in = 32'd0;
      k_reg.write_en = 1'b1;
      reset_k[done] = k_reg.done;
    }

    group reset_sum {
      sum_reg.in = 32'd0;
      sum_reg.write_en = 1'b1;
      reset_sum[done] = sum_reg.done;
    }

    static<5> group multiply {
      mult.left = a_reg.out;
      mult.right = b_reg.out;
      mult_reg.in = mult.out;
      mult_reg.write_en = 1'b1;
    }

    group update_sum {
      add.left = sum_reg.out;
      add.right = mult_reg.out;
      sum_reg.in = add.out;
      sum_reg.write_en = 1'b1;
      update_sum[done] = sum_reg.done;
    }

    group update_mem {
      out_mem.addr0 = i_reg.out;
      out_mem.addr1 = j_reg.out;
      out_mem.write_data = sum_reg.out;
      out_mem.write_en = 1'b1;
      update_mem[done] = out_mem.done;
    }

    comb group cond_i {
      lt1.left = i_reg.out;
      lt1.right = 32'd2;
    }

    comb group cond_j {
      lt2.left = j_reg.out;
      lt2.right = 32'd2;
    }

    comb group cond_k {
      lt3.left = k_reg.out;
      lt3.right = 32'd2;
    }
  }
  control {
    seq {
      reset_i;
      while lt1.out with cond_i {
        seq {
          reset_j;
          while lt2.out with cond_j {
            seq {
              par {
                reset_sum;
                reset_k;
              }
              while lt3.out with cond_k {
                seq {
                  par {
                    load_a;
                    load_b;
                  }
                  multiply;
                  update_sum;
                  incr_k;
                }
              }
              update_mem;
            }
            incr_j;
          }
          incr_i;
        }
      }
    }
  }
}
