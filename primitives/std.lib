primitive std_mem_d1[p_width, p_size, p_idx_size](
  addr0: p_idx_size,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width, done: 1) {
  verilog {
    module std_mem_d1
      #(parameter width = 32,
        parameter size = 16,
        parameter idx_size = 4)
       (input logic [idx_size-1:0] addr0,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data,
        output logic done);

      logic [width-1:0]  mem[size-1:0];

      assign read_data = mem[addr0];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0] <= write_data;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_mem_d2[p_width, d0_size, d1_size, d0_idx_size, d1_idx_size](
  addr0: d0_idx_size,
  addr1: d1_idx_size,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width, done: 1) {
  verilog {
    module std_mem_d2
      #(parameter width = 32,
        parameter d0_size = 16,
        parameter d1_size = 16,
        parameter d0_idx_size = 4,
        parameter d1_idx_size = 4)
       (input logic [d0_idx_size-1:0] addr0,
        input logic [d1_idx_size-1:0] addr1,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data,
        output logic done);

      logic [width-1:0]  mem[d0_size-1:0][d1_size-1:0];

      assign read_data = mem[addr0][addr1];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0][addr1] <= write_data;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_mem_d3[
    p_width,
    d0_size,
    d1_size,
    d2_size,
    d0_idx_size,
    d1_idx_size,
    d2_idx_size
] (
  addr0: d0_idx_size,
  addr1: d1_idx_size,
  addr2: d2_idx_size,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width, done: 1) {
  verilog {
    module std_mem_d3
      #(parameter width = 32,
        parameter d0_size = 16,
        parameter d1_size = 16,
        parameter d2_size = 16,
        parameter d0_idx_size = 4,
        parameter d1_idx_size = 4,
        parameter d2_idx_size = 4)
       (input logic [d0_idx_size-1:0] addr0,
        input logic [d1_idx_size-1:0] addr1,
        input logic [d2_idx_size-1:0] addr2,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data,
        output logic done);

      logic [width-1:0]  mem[d0_size-1:0][d1_size-1:0][d2_size-1:0];

      assign read_data = mem[addr0][addr1];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0][addr1][addr2] <= write_data;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_logsize_mem_d1[p_width, p_logsize](
  addr0: p_logsize,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width) {
  verilog {
    module std_logsize_mem_d1
      #(parameter width = 32,
        parameter logsize = 4)
       (input logic [logsize-1:0] addr0,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data);

      logic [width-1:0]  mem[(1<<logsize)-1:0];

      assign read_data = mem[addr0];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0] <= write_data;
        end
      end
    endmodule
  }
}

primitive std_reg<"static"=1>[p_width](in: p_width, write_en: 1, clk: 1) -> (out: p_width, done: 1) {
  verilog {
    module std_reg
      #(parameter width = 32)
       (input wire [width-1:0] in,
        input wire write_en,
        input wire clk,
        // output
        output logic [width - 1:0] out,
        output logic done);

      always_ff @(posedge clk) begin
        if (write_en) begin
          out <= in;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_iterator[p_width, p_start, p_stop, p_incr]
    (valid: 1, clk: 1)
    -> (out: p_width, stop: 1, out_read_out: 1, ready: 1)
  {}

primitive std_const[p_width, p_value](valid: 1) -> (out: p_width, out_read_out: 1, ready: 1) {
  verilog {
    module std_const
      #(parameter width = 32,
        parameter value = 0)
       (input logic                valid,
        output logic               ready,
        output logic [width - 1:0] out,
        output logic               out_read_out);
      assign out = value;
      assign ready = valid;
      assign out_read_out = valid;
    endmodule
  }
}

primitive std_add[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_add
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left + right;
    endmodule
  }
}

primitive std_sub[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_sub
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left - right;
    endmodule
  }
}

primitive std_mult[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_mult
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left * right;
    endmodule
  }
}

primitive std_div[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_div
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left / right;
    endmodule
  }
}

primitive std_not[p_width](in: p_width) -> (out: p_width) {
  verilog {
    module std_not
      #(parameter width = 32)
      (input logic [width-1:0] in,
        output logic [width-1:0] out);
      assign out = ~in;
    endmodule
  }
}

primitive std_and[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_and
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left & right;
    endmodule
  }
}

primitive std_or[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_or
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left | right;
    endmodule
  }
}

primitive std_gt[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_gt
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left > right;
    endmodule
  }
}

primitive std_lt[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_lt
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left < right;
    endmodule
  }
}

primitive std_eq[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_eq
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left == right;
    endmodule
  }
}

primitive std_neq[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_neq
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left != right;
    endmodule
  }
}

primitive std_ge[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_ge
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left >= right;
    endmodule
  }
}

primitive std_le[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_le
      #(parameter width = 32)
      (input logic [width-1:0] left,
       input logic [width-1:0] right,
       output logic            out);
      assign out = left <= right;
    endmodule
  }
}

primitive std_start_fsm(valid: 1, reset: 1, clk: 1) -> (out: 1) {
  verilog {
    module std_start_fsm
     (input logic  valid,
      input logic  reset,
      input logic  clk,
      // outputs
      output logic out);

      logic        state;
      always_ff @(posedge clk) begin
      if (reset) begin
        out <= 1'b0;
        state <= 1'b0;
      end else
        case ({valid, state})
          2'b00: out <= 1'b0;
          2'b10: begin
            state <= 1'b1;
            out <= 1'b1;
          end
          2'b01: out <= 1'b0;
          2'b11: out <= 1'b0;
        endcase
      end
    endmodule
  }
}

primitive std_fsm_state(in: 1, reset: 1, clk: 1) -> (out: 1) {
 verilog {
    module std_fsm_state
      (input logic  in,
       input logic  reset,
       input logic  clk,
       // outputs
       output logic out);

      logic        state;

      always_ff @(posedge clk) begin
        if (reset) state <= 1'b0;
        else begin
          state <= in;
        end
      end

      always_comb
        out = state;
    endmodule
  }
}
