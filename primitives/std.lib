
(define/library
  (define/prim std_reg (p_width)
    ((port in p_width)
     (port write_en 1)
     (port clk 1))
    ((port out p_width))
    ((verilog
"module std_reg
  #(parameter width = 32,
    parameter reset_val = 0)
    (input logic  [width-1:0] in,
     input logic              write_en,
     input logic              clk,
     // output
     output logic [width - 1:0] out);

    logic [width-1:0]           register;
    always_ff @(posedge clk) begin
      if (write_en) begin
        register <= in;
      end
    end

    assign out = register;
endmodule")))

  (define/prim std_iterator (p_width p_start p_stop p_incr)
    ((port valid 1)
     (port clk 1))
    ((port out p_width)
     (port stop 1)
     (port out_read_out 1)
     (port ready 1))
    ())

  (define/prim std_const (p_width p_value)
    ((port valid 1))
    ((port out p_width)
     (port out_read_out 1)
     (port ready 1))
    ((verilog
"module std_const
  #(parameter width = 32,
    parameter value = 0)
   (input logic                valid,
    output logic               ready,
    output logic [width - 1:0] out,
    output logic               out_read_out);
   assign out = value;
   assign ready = valid;
   assign out_read_out = valid;
endmodule")))

  (define/prim std_add (p_width)
    ((port left p_width) (port right p_width))
    ((port out p_width))
    ((verilog
"module std_add
  #(parameter width = 32)
   (input  logic [width-1:0] left,
    input  logic [width-1:0] right,
    output logic [width-1:0] out);
   assign out = left + right;
endmodule")))

  (define/prim std_sub (p_width)
    ((port left p_width) (port right p_width))
    ((port out p_width))
    ((verilog
"module std_sub
  #(parameter width = 32)
   (input  logic [width-1:0] left,
    input  logic [width-1:0] right,
    output logic [width-1:0] out);
   assign out = left - right;
endmodule")))

  (define/prim std_mul (p_width)
   ((port left p_width) (port right p_width))
   ((port out p_width))
   ((verilog
"module std_mul
  #(parameter width = 32)
   (input logic  [width-1:0] left,
    input logic  [width-1:0] right,
    output logic [width-1:0] out);
   assign out = left * right;
endmodule")))

  (define/prim std_div (p_width)
   ((port left p_width) (port right p_width))
   ((port out p_width))
   ((verilog
"module std_div
  #(parameter width = 32)
   (input logic  [width-1:0] left,
    input logic  [width-1:0] right,
    output logic [width-1:0] out);
   assign out = left / right;
endmodule")))

  (define/prim std_not (p_width)
    ((port in p_width) (port valid 1))
    ((port out p_width) (port ready 1))
   ())

  (define/prim std_and (p_width)
   ((port left p_width) (port right p_width))
   ((port out p_width))
   ((verilog
"module std_and
  #(parameter width = 32)
   (input logic  [width-1:0] left,
    input logic  [width-1:0] right,
    output logic [width-1:0] out);
   assign out = left & right;
endmodule")))

  (define/prim std_or (p_width)
   ((port left p_width) (port right p_width))
   ((port out p_width))
   ((verilog
"module std_or
  #(parameter width = 32)
   (input logic  [width-1:0] left,
    input logic  [width-1:0] right,
    output logic [width-1:0] out);
   assign out = left | right;
endmodule")))

  (define/prim std_gt (p_width)
   ((port left p_width) (port right p_width))
   ((port out 1))
   ((verilog
"module std_gt
  #(parameter width = 32)
   (input logic [width-1:0] left,
    input logic [width-1:0] right,
    output logic            out);
   assign out = left > right;
endmodule")))

  (define/prim std_lt (p_width)
   ((port left p_width) (port right p_width))
   ((port out 1))
   ((verilog
"module std_lt
  #(parameter width = 32)
   (input logic [width-1:0] left,
    input logic [width-1:0] right,
    output logic            out);
   assign out = left < right;
endmodule")))

  (define/prim std_eq (p_width)
   ((port left p_width) (port right p_width))
   ((port out 1))
   ((verilog
"module std_eq
  #(parameter width = 32)
   (input logic [width-1:0] left,
    input logic [width-1:0] right,
    output logic            out);
   assign out = left == right;
endmodule")))

  (define/prim std_neq (p_width)
   ((port left p_width) (port right p_width))
   ((port out 1))
   ((verilog
"module std_neq
  #(parameter width = 32)
   (input logic [width-1:0] left,
    input logic [width-1:0] right,
    output logic            out);
   assign out = left != right;
endmodule")))

  (define/prim std_ge (p_width)
   ((port left p_width) (port right p_width))
   ((port out p_width))
   ((verilog
"module std_ge
  #(parameter width = 32)
   (input logic [width-1:0] left,
    input logic [width-1:0] right,
    output logic            out);
   assign out = left >= right;
endmodule")))

  (define/prim std_le (p_width)
   ((port left p_width) (port right p_width))
   ((port out 1))
   ((verilog
"module std_le
  #(parameter width = 32)
   (input logic [width-1:0] left,
    input logic [width-1:0] right,
    output logic            out);
   assign out = left <= right;
endmodule")))

  (define/prim std_start_fsm ()
   ((port valid 1) (port reset 1) (port clk 1))
   ((port out 1))
   ((verilog
"module std_start_fsm
  (input logic  valid,
   input logic  reset,
   input logic  clk,
   // outputs
   output logic out);

  logic        state;
  always_ff @(posedge clk) begin
  if (reset) begin
    out <= 1'b0;
    state <= 1'b0;
  end else
    case ({valid, state})
      2'b00: out <= 1'b0;
      2'b10: begin
        state <= 1'b1;
        out <= 1'b1;
      end
      2'b01: out <= 1'b0;
      2'b11: out <= 1'b0;
    endcase
  end
endmodule")))

  (define/prim std_fsm_state ()
   ((port in 1) (port reset 1) (port clk 1))
   ((port out 1))
   ((verilog
"module std_fsm_state
  (input logic  in,
   input logic  reset,
   input logic  clk,
   // outputs
   output logic out);

  logic        state;

  always_ff @(posedge clk) begin
    if (reset) state <= 1'b0;
    else begin
      state <= in;
    end
  end

  always_comb
    out = state;
endmodule"))))

