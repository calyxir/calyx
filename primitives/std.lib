primitive std_mem_d1[p_width, p_size, p_idx_size](
  addr0: p_idx_size,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width, done: 1) {
  verilog {
    module std_mem_d1
      #(parameter width = 32,
        parameter size = 16,
        parameter idx_size = 4)
       (input logic [idx_size-1:0] addr0,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data,
        output logic done);

      logic [width-1:0]  mem[size-1:0];

      assign read_data = mem[addr0];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0] <= write_data;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

// Represents an external memory
primitive std_mem_d1_ext[p_width, p_size, p_idx_size](
  addr0: p_idx_size,
  write_data: p_width,
  write_en: 1
) -> (read_data: p_width, done: 1) {}


primitive std_mem_d2[p_width, d0_size, d1_size, d0_idx_size, d1_idx_size](
  addr0: d0_idx_size,
  addr1: d1_idx_size,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width, done: 1) {
  verilog {
    module std_mem_d2
      #(parameter width = 32,
        parameter d0_size = 16,
        parameter d1_size = 16,
        parameter d0_idx_size = 4,
        parameter d1_idx_size = 4)
       (input logic [d0_idx_size-1:0] addr0,
        input logic [d1_idx_size-1:0] addr1,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data,
        output logic done);

      logic [width-1:0]  mem[d0_size-1:0][d1_size-1:0];

      assign read_data = mem[addr0][addr1];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0][addr1] <= write_data;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_mem_d2_ext[p_width, d0_size, d1_size, d0_idx_size, d1_idx_size](
  addr0: d0_idx_size,
  addr1: d1_idx_size,
  write_data: p_width,
  write_en: 1
) -> (read_data: p_width, done: 1) {}

primitive std_mem_d3[
    p_width,
    d0_size,
    d1_size,
    d2_size,
    d0_idx_size,
    d1_idx_size,
    d2_idx_size
] (
  addr0: d0_idx_size,
  addr1: d1_idx_size,
  addr2: d2_idx_size,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width, done: 1) {
  verilog {
    module std_mem_d3
      #(parameter width = 32,
        parameter d0_size = 16,
        parameter d1_size = 16,
        parameter d2_size = 16,
        parameter d0_idx_size = 4,
        parameter d1_idx_size = 4,
        parameter d2_idx_size = 4)
       (input logic [d0_idx_size-1:0] addr0,
        input logic [d1_idx_size-1:0] addr1,
        input logic [d2_idx_size-1:0] addr2,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data,
        output logic done);

      logic [width-1:0]  mem[d0_size-1:0][d1_size-1:0][d2_size-1:0];

      assign read_data = mem[addr0][addr1];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0][addr1][addr2] <= write_data;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_mem_d3_ext[
    p_width,
    d0_size,
    d1_size,
    d2_size,
    d0_idx_size,
    d1_idx_size,
    d2_idx_size
] (
  addr0: d0_idx_size,
  addr1: d1_idx_size,
  addr2: d2_idx_size,
  write_data: p_width,
  write_en: 1
) -> (read_data: p_width, done: 1) {}

primitive std_logsize_mem_d1[p_width, p_logsize](
  addr0: p_logsize,
  write_data: p_width,
  write_en: 1,
  clk: 1
) -> (read_data: p_width) {
  verilog {
    module std_logsize_mem_d1
      #(parameter width = 32,
        parameter logsize = 4)
       (input logic [logsize-1:0] addr0,
        input logic [width-1:0]   write_data,
        input logic               write_en,
        input logic               clk,
        output logic [width-1:0]  read_data);

      logic [width-1:0]  mem[(1<<logsize)-1:0];

      assign read_data = mem[addr0];
      always_ff @(posedge clk) begin
        if (write_en) begin
          mem[addr0] <= write_data;
        end
      end
    endmodule
  }
}

primitive std_reg<"static"=1>[p_width](in: p_width, write_en: 1, clk: 1) -> (out: p_width, done: 1) {
  verilog {
    module std_reg
      #(parameter width = 32)
       (input wire [width-1:0] in,
        input wire write_en,
        input wire clk,
        // output
        output logic [width - 1:0] out,
        output logic done);

      always_ff @(posedge clk) begin
        if (write_en) begin
          out <= in;
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_shift_reg[p_width, p_depth](in: p_width, write_en: 1, clk: 1) -> (out: p_width, done: 1) {
  verilog {
    module std_shift_reg
      #(parameter WIDTH = 32,
        parameter DEPTH = 1)
       (// inputs
        input logic [WIDTH-1:0] in,
        input logic write_en,
        // clock
        input logic clk,
        // outputs
        output logic [WIDTH-1:0] out,
        output logic done);

      // Register file to store values being shifted.
      logic [WIDTH-1:0] shift_reg[0:DEPTH-1];
      // Local variable to shift the register with.
      logic [WIDTH-1:0] push_in;

      // The output is always the right-most value.
      assign out = shift_reg[DEPTH-1];

      // Select what value needs to be pushed in this cycle.
      always_comb begin
        if (write_en)
          push_in = in;
        else
          push_in = '0;
      end

      // Shift all the value to the right.
      genvar i;
      generate for (i=0; i<DEPTH - 1; i=i+1)
      always_ff @(posedge clk)
        shift_reg[i+1] <= shift_reg[i];
      endgenerate

      always_ff @(posedge clk) begin
        // If a value was written, send the done signal.
        if (write_en) begin
          done <= 1'd1;
        end else
          done <= 1'd0;

        // Push new value into the register
        shift_reg[0] <= push_in;
      end
    endmodule
  }
}

primitive std_const[p_width, p_value]() -> (out: p_width) {
  verilog {
    module std_const
      #(parameter width = 32,
        parameter value = 0)
       (output logic [width - 1:0] out);
      assign out = value;
    endmodule
  }
}

primitive std_lsh[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_add
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left << right;
    endmodule
  }
}

primitive std_rsh[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_add
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left >> right;
    endmodule
  }
}

primitive std_add[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_add
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left + right;
    endmodule
  }
}

primitive std_sub[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_sub
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left - right;
    endmodule
  }
}

primitive std_mod[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_mod
      #(parameter width = 32)
      (input  logic [width-1:0] left,
        input  logic [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left % right;
    endmodule
  }
}

primitive std_mult[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_mult
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left * right;
    endmodule
  }
}

primitive std_mult_pipe[p_width](left: p_width, right: p_width, go: 1, clk: 1) -> (out: p_width, done: 1) {
  verilog {
    module std_mult_pipe
      #(parameter width = 32)
       (input logic [width-1:0] left,
        input logic [width-1:0] right,
        input logic go,
        input logic clk,
        output logic [width-1:0] out,
        output logic done);
       logic [width-1:0] rtmp;
       logic [width-1:0] ltmp;
       logic [width-1:0] out_tmp;
       reg done_buf[1:0];
       always_ff @(posedge clk) begin
         if (go) begin
           rtmp <= right;
           ltmp <= left;
           out_tmp <= rtmp * ltmp;
           out <= out_tmp;

           done <= done_buf[1];
           done_buf[0] <= 1'b1;
           done_buf[1] <= done_buf[0];
         end else begin
           rtmp <= 0;
           ltmp <= 0;
           out_tmp <= 0;
           out <= 0;

           done <= 0;
           done_buf[0] <= 0;
           done_buf[1] <= 0;
         end
       end
     endmodule
  }
}

primitive std_div[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_div
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left / right;
    endmodule
  }
}

primitive std_not[p_width](in: p_width) -> (out: p_width) {
  verilog {
    module std_not
      #(parameter width = 32)
      (input logic [width-1:0] in,
        output logic [width-1:0] out);
      assign out = ~in;
    endmodule
  }
}

primitive std_and[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_and
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left & right;
    endmodule
  }
}

primitive std_or[p_width](left: p_width, right: p_width) -> (out: p_width) {
  verilog {
    module std_or
      #(parameter width = 32)
      (input logic  [width-1:0] left,
        input logic  [width-1:0] right,
        output logic [width-1:0] out);
      assign out = left | right;
    endmodule
  }
}

primitive std_gt[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_gt
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left > right;
    endmodule
  }
}

primitive std_lt[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_lt
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left < right;
    endmodule
  }
}

primitive std_eq[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_eq
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left == right;
    endmodule
  }
}

primitive std_neq[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_neq
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left != right;
    endmodule
  }
}

primitive std_ge[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_ge
      #(parameter width = 32)
      (input logic [width-1:0] left,
        input logic [width-1:0] right,
        output logic            out);
      assign out = left >= right;
    endmodule
  }
}

primitive std_le[p_width](left: p_width, right: p_width) -> (out: 1) {
  verilog {
    module std_le
      #(parameter width = 32)
      (input logic [width-1:0] left,
       input logic [width-1:0] right,
       output logic            out);
      assign out = left <= right;
    endmodule
  }
}

// XXX(sam): parameterize input and output width
primitive std_sqrt(in: 32, go: 1, clk: 1) -> (out: 32, done: 1) {
  verilog {
    module std_sqrt
      (input logic [31:0]  in,
       input logic         go,
       input logic         clk,
       output logic [31:0] out,
       output logic        done);
      // declare the variables
      reg [31:0] a;
      reg [15:0] q;
      reg [17:0] left,right,r;
      integer i;

      always_ff @(posedge clk) begin
        // initialize all the variables.
        a = in;
        q = 0;
        i = 0;
        left = 0;   // input to adder/sub
        right = 0;  // input to adder/sub
        r = 0;      // remainder

        // run the calculations for 16 iterations.
        for(i=0;i<16;i=i+1) begin
            right = {q,r[17],1'b1};
            left = {r[15:0],a[31:30]};
            a = {a[29:0],2'b00};    //left shift by 2 bits.
            if (r[17] == 1) //add if r is negative
                r = left + right;
            else    //subtract if r is positive
                r = left - right;
            q = {q[14:0],!r[17]};
        end
        out = {16'd0,q};   //final assignment of output.
      end

      always_ff @(posedge clk) begin
        if (go) begin
          done <= 1'd1;
        end else
          done <= 1'd0;
      end
    endmodule
  }
}

primitive std_start_fsm(valid: 1, reset: 1, clk: 1) -> (out: 1) {
  verilog {
    module std_start_fsm
     (input logic  valid,
      input logic  reset,
      input logic  clk,
      // outputs
      output logic out);

      logic        state;
      always_ff @(posedge clk) begin
      if (reset) begin
        out <= 1'b0;
        state <= 1'b0;
      end else
        case ({valid, state})
          2'b00: out <= 1'b0;
          2'b10: begin
            state <= 1'b1;
            out <= 1'b1;
          end
          2'b01: out <= 1'b0;
          2'b11: out <= 1'b0;
        endcase
      end
    endmodule
  }
}

primitive std_fsm_state(in: 1, reset: 1, clk: 1) -> (out: 1) {
 verilog {
    module std_fsm_state
      (input logic  in,
       input logic  reset,
       input logic  clk,
       // outputs
       output logic out);

      logic        state;

      always_ff @(posedge clk) begin
        if (reset) state <= 1'b0;
        else begin
          state <= in;
        end
      end

      always_comb
        out = state;
    endmodule
  }
}
