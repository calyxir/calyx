WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ ("//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE) | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

ident_syms = _{ "_" | "-" | "'" }
identifier = @{ ASCII_ALPHA+ ~ (ident_syms | ASCII_ALPHA | ASCII_DIGIT)* }

bitwidth = @{ ASCII_DIGIT+ }

// Conservatively parse all symbols to provide better errors.
binary =  @{ ASCII_HEX_DIGIT+ }
decimal = @{ ASCII_HEX_DIGIT+ }
octal =   @{ ASCII_HEX_DIGIT+ }
hex =     @{ ASCII_HEX_DIGIT+ }

// `$` creates a compound rule which ignores whitespace while allowing for
// inner rules (`@` makes inner rules silent).
// See: https://pest.rs/book/print.html#atomic
num_lit = ${
      bitwidth
      ~ "'"
      ~ ( "d" ~ decimal
        | "b" ~ binary
        | "x" ~ hex
        | "o" ~ octal )
}

char = { !"\"" ~ ANY }
string_lit = ${ "\"" ~ char* ~ "\"" }

// Error reporting rule: Expected a number with bitwidth in this position.
bad_num = @{ ASCII_DIGIT ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "'")* }

// ====== toplevel ======

component = {
      "component" ~ identifier ~ signature
      ~ "{"
      ~ cells
      ~ connections
      ~ control
      ~ "}"
}

file = {
      SOI
      ~ imports
      ~ component+
      ~ EOI
}

import = _{
      "import" ~ string_lit ~ ";"
}

imports = { import* }


// ====== signature ======

signature = {
      "(" ~ io_ports? ~ ")" ~ signature_return
}

signature_return = {
      "->" ~ "(" ~ io_ports? ~ ")"
}

io_port = {
      identifier ~ ":" ~ bitwidth
}

io_ports = {
      io_port ~ ("," ~ io_port)*
}

args = {
      "(" ~ (bitwidth ~ ("," ~ bitwidth)*)? ~ ")"
}

// ====== cells ======

primitive_cell = {
      identifier ~ "=" ~ "prim" ~ identifier ~ args
}

component_cell = {
      identifier ~ "=" ~ identifier
}

cell = {
      (primitive_cell | component_cell) ~ ";"
}

cells = {
      "cells"
      ~ "{" ~ cell* ~ "}"
}

// ====== wires ======

hole = {
      identifier ~ "[" ~ identifier ~ "]"
}

port = {
      (identifier ~ "." ~ identifier)
    | identifier
}

LHS = { hole | port }
expr = {
  LHS
  | num_lit
  | bad_num // throws an error
}

guard_eq = { "==" }
guard_neq = { "!=" }
guard_leq = { "<=" }
guard_geq = { ">=" }
guard_lt = { "<" }
guard_gt = { ">" }
guard_or = { "|" }
guard_and = { "&" }
guard_not = { "!" }
operator = _{
      guard_eq | guard_neq | guard_leq | guard_geq
    | guard_lt | guard_gt | guard_or | guard_and
    | guard_not
}

guard_expr = {
      term ~ (operator ~ term)*
}

term = {
      guard_not ~ expr | guard_not ~ guard_expr | "(" ~ guard_expr ~ ")" | expr
}

switch_stmt = {
      guard_expr ~ "?" ~ expr
}

wire = {
      LHS ~ "=" ~ (switch_stmt | expr) ~ ";"
}

key_value = {
      string_lit ~ "=" ~ bitwidth
}

attributes = {
      "<" ~ (key_value ~ ("," ~ key_value)*) ~ ">"
}

group = {
      "group" ~ identifier ~ attributes? ~ "{"
      ~ wire*
      ~ "}"
}

connections = {
      "wires"
      ~ "{"
      ~ (wire | group)*
      ~ "}"
}

// ====== control ======

enable = { identifier ~ ";" }

invoke_arg = { identifier ~ "=" ~ port }
invoke_args = { (invoke_arg ~ ("," ~ invoke_arg)*)? }
invoke = { "invoke" ~ identifier ~ "(" ~ invoke_args ~ ")" ~ "(" ~ invoke_args ~ ")" ~ ";" }

seq = {
      "seq" ~ "{"
      ~ stmt*
      ~ "}"
}

par = {
      "par" ~ "{"
      ~ stmt*
      ~ "}"
}

// Error reporting rule: these statements should be inside a `stmt`.
stmts_without_block = {
  "{" ~ stmt* ~ "}"
}

block = {
      "{" ~ stmt ~ "}"
      | stmts_without_block
}

if_stmt = {
      "if" ~ port ~ "with" ~ identifier ~ block ~ ("else" ~ (if_stmt | block))?
}

while_stmt = {
      "while" ~ port ~ "with" ~ identifier ~ block
}

stmt = {
      enable
    | invoke
    | (seq ~ ";"?)
    | (par ~ ";"?)
    | (if_stmt ~ ";"?)
    | (while_stmt ~ ";"?)
}

control = {
      "control" ~ (("{" ~ "}") | block)
}
