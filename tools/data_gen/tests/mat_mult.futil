import "primitives/core.futil";
import "primitives/binary_operators.futil";

component mult_matrix(m1_done:1, m1_read_data:32, m2_done:1, m2_read_data:32, m1_rows:4, m1_cols:4, m2_cols:4, r_done:1, r_read_data:32) ->
(r_write_data:32, r_write_en:1, r_addr0:4, r_addr1:4, m1_addr0:4, m1_addr1:4, m2_addr0:4, m2_addr1:4, m1_write_en:1, m2_write_en:1){
  cells {
    A_read = std_reg(32);
    B_read = std_reg(32);
    prod_reg = std_reg(32);
    add_32 = std_add(32);
    mult_32 = std_mult_pipe(32);
    add_4 = std_add(4);
    i = std_reg(4); 
    j = std_reg(4); 
    k = std_reg(4); 
    lt = std_lt(4); 
  }
  wires {
    comb group i_lt_m1rows {
      lt.left = i.out;
      lt.right = m1_rows;
    }

    comb group j_lt_m2cols {
      lt.left = j.out;
      lt.right = m2_cols;
    }

    comb group k_lt_m1cols {
      lt.left = k.out;
      lt.right = m1_cols;
    }

    //setting i = 0
    group leti {
      i.in = 4'd0;
      i.write_en = 1'd1;
      leti[done] = i.done;
    }

    //setting j = 0
    group letj {
      j.in = 4'd0;
      j.write_en = 1'd1;
      letj[done] = j.done;
    }

    //setting k = 0
    group letk {
      k.in = 4'd0;
      k.write_en = 1'd1;
      letk[done] = k.done;
    }
    
    group get_product {
      prod_reg.in = mult_32.out;
      prod_reg.write_en = mult_32.done;
      get_product[done] = prod_reg.done;
      mult_32.left = A_read.out;
      mult_32.right = B_read.out;
      mult_32.go = !mult_32.done ? 1'd1;
    }

    group read_A {
      A_read.write_en = 1'd1;
      m1_addr0 = i.out;
      m1_addr1 = k.out; 
      A_read.in = m1_read_data;
      read_A[done] = A_read.done; 
    }

    group read_B {
      B_read.write_en = 1'd1;
      m2_addr0 = k.out;
      m2_addr1 = j.out; 
      B_read.in = m2_read_data;
      read_B[done] = B_read.done;
    }

    group update_value {
      r_write_en = 1'd1; 
      r_addr0 = i.out; 
      r_addr1 = j.out; 
      add_32.left = r_read_data; 
      add_32.right = prod_reg.out; 
      r_write_data = add_32.out; 
      update_value[done] = r_done; 
    }

    group incr_k{
      k.write_en = 1'd1; 
      add_4.left = k.out; 
      add_4.right = 4'd1; 
      k.in = add_4.out; 
      incr_k[done] = k.done; 
    }

    group incr_j{
      j.write_en = 1'd1; 
      add_4.left = j.out; 
      add_4.right = 4'd1; 
      j.in = add_4.out; 
      incr_j[done] = j.done; 
    }

    group incr_i{
      i.write_en = 1'd1; 
      add_4.left = i.out; 
      add_4.right = 4'd1; 
      i.in = add_4.out; 
      incr_i[done] = i.done; 
    }
  }
  control {
    seq {
      leti;
      letj; 
      letk;
      while lt.out with i_lt_m1rows {
        seq{
          while lt.out with j_lt_m2cols{
            seq{
              while lt.out with k_lt_m1cols{
                seq {
                  par {
                    read_A;
                    read_B;
                  }
                  get_product;
                  update_value;
                  incr_k;
                }
              }
              letk; 
              incr_j;
            }
        }
        letj; 
        incr_i;
        }
      }
    }
  }              
}


component main() -> () {
  cells {
    @external(1) A = std_mem_d2(32,2,3,4,4);
    @external(1) B = std_mem_d2(32,3,4,4,4);
    @external(1) R = std_mem_d2(32,2,4,4,4);
    m1_rows = std_const(4,2); 
    m1_cols = std_const(4,3);
    m2_cols = std_const(4,4);

    mat_mult = mult_matrix(); 
  }
  wires {
  
  }
  control {
    seq{
      invoke mat_mult(m1_done = A.done, m1_read_data = A.read_data, m2_done = B.done, m2_read_data = B.read_data, m1_rows = m1_rows.out, m1_cols = m1_cols.out, m2_cols = m2_cols.out, r_done = R.done, r_read_data = R.read_data)
                      (r_write_data = R.write_data, r_write_en = R.write_en, r_addr0 = R.addr0, r_addr1 = R.addr1, m1_addr0 = A.addr0, m1_addr1 = A.addr1, m2_addr0 = B.addr0, m2_addr1 = B.addr1, m1_write_en = A.write_en, m2_write_en = B.write_en);
    } 
  }
}
