import json
import os

from collections import defaultdict
from profiler.classes import CellMetadata, ControlMetadata, ParChildType


def read_shared_cells_map(shared_cells_json) -> dict[str, dict[str, str]]:
    """
    Reads shared_cells_json and returns map of cells that are being shared via the cell-sharing pass.
    """
    shared_cells_map = {}
    if not os.path.isfile(shared_cells_json):
        print(
            f"[read_shared_cells_map] {shared_cells_json} not found! Either cell sharing was not run, or there's a bug."
        )
        return {}
    json_map = json.load(open(shared_cells_json))
    for component in json_map:
        shared_cells_map[component] = {}
        for entry in json_map[component]:
            original = entry["original"]
            new = entry["new"]
            shared_cells_map[component][original] = new
    return shared_cells_map


def build_components_to_cells(
    prefix, curr_component, cells_to_components, components_to_cells
):
    """
    Generates a list of all of the components to potential cell names
    `prefix` is the cell's "path" (ex. for a cell "my_cell" defined in "main", the prefix would be "TOP.toplevel.main")
    The initial value of curr_component should be the top level/main component
    """
    for cell, cell_component in cells_to_components[curr_component].items():
        if cell_component not in components_to_cells:
            components_to_cells[cell_component] = [f"{prefix}.{cell}"]
        else:
            components_to_cells[cell_component].append(f"{prefix}.{cell}")
        build_components_to_cells(
            prefix + f".{cell}",
            cell_component,
            cells_to_components,
            components_to_cells,
        )


def read_component_cell_names_json(json_file):
    """
    Reads json generated by component-cells backend to produce a mapping from all components
    to cell names they could have.

    NOTE: Cell names by this point don't contain the simulator-specific prefix. This will be
    filled by VCDConverter.enddefinitions(). (This is because the simulator-specific prefix
    also depends on the OS being used, and may be different based on the machine.)
    """
    cell_json = json.load(open(json_file))
    # For each component, contains a map from each cell name to its corresponding component
    # component name --> { cell name --> component name }
    cells_to_components = {}
    main_component = ""
    for curr_component_entry in cell_json:
        cell_map = {}  # mapping cell names to component names for all cells in the current component
        if curr_component_entry["is_main_component"]:
            main_component = curr_component_entry["component"]
        for cell_info in curr_component_entry["cell_info"]:
            cell_map[cell_info["cell_name"]] = cell_info["component_name"]
        cells_to_components[curr_component_entry["component"]] = cell_map
    components_to_cells = {
        main_component: [main_component]
    }  # come up with a better name for this
    build_components_to_cells(
        main_component, main_component, cells_to_components, components_to_cells
    )
    # semi-fully_qualified_cell_name --> component name (of cell)
    # I say semi-here because the prefix depends on the simulator + OS
    # (ex. "TOP.toplevel" for Verilator on ubuntu)
    cell_names_to_components = {}
    for component in components_to_cells:
        for cell in components_to_cells[component]:
            cell_names_to_components[cell] = component

    return CellMetadata(main_component, components_to_cells)


def read_ctrl_metadata_file(ctrl_map_file: str):
    component_to_pos_to_loc_str: defaultdict[str, defaultdict[int, str]] = defaultdict()

    json_data = json.load(open(ctrl_map_file, "r"))
    for component in json_data:
        component_to_pos_to_loc_str[component] = defaultdict(str)
        for entry in json_data[component]:
            pos_num = entry["pos_num"]
            line_num = entry["linenum"]
            ctrl_node_name = entry["ctrl_node"]
            component_to_pos_to_loc_str[component][pos_num] = (
                f"{ctrl_node_name}@L{line_num}"
            )

    return component_to_pos_to_loc_str


def read_tdcc_file(
    tdcc_json_file: str,
    component_to_pos_to_loc_str: defaultdict[str, defaultdict[int, str]] | None,
    cell_metadata: CellMetadata,
):
    """
    Processes tdcc_json_file to produce information about control registers (FSMs, pd registers for pars)
    and par groups.
    """
    json_data = json.load(open(tdcc_json_file))
    control_metadata = ControlMetadata()
    if component_to_pos_to_loc_str is not None:
        control_metadata.component_to_ctrl_group_to_pos_str = defaultdict()
        for component in cell_metadata.component_to_cells.keys():
            control_metadata.component_to_ctrl_group_to_pos_str[component] = (
                defaultdict(str)
            )
    # pass 1: obtain names of all par groups in each component
    for json_entry in json_data:
        if "Par" in json_entry:
            control_metadata.register_par(
                json_entry["Par"]["par_group"], json_entry["Par"]["component"]
            )
    # pass 2: obtain FSM register info, par group and child register information
    for json_entry in json_data:
        if "Fsm" in json_entry:
            entry = json_entry["Fsm"]
            ctrl_group = entry["group"]
            component = entry["component"]
            pos_list = entry["pos"]
            control_metadata.register_fsm(
                entry["fsm"], entry["component"], cell_metadata
            )
            calyx_pos_list: list[int] = list(
                filter(
                    lambda x: component_to_pos_to_loc_str is not None
                    and x in component_to_pos_to_loc_str[component],
                    pos_list,
                )
            )
            assert len(calyx_pos_list) <= 1
            if len(calyx_pos_list) == 1:
                # if we have a control position, look up its corresponding
                loc_str = component_to_pos_to_loc_str[component][calyx_pos_list[0]]
                control_metadata.component_to_ctrl_group_to_pos_str[component][
                    ctrl_group
                ] = loc_str
            for cell in cell_metadata.component_to_cells[entry["component"]]:
                control_metadata.register_fully_qualified_ctrl_gp(
                    f"{cell}.{ctrl_group}"
                )
                control_metadata.cell_to_tdcc_groups[cell].add(ctrl_group)
                control_metadata.component_to_control_to_primitives[entry["component"]][
                    entry["group"]
                ].add(entry["fsm"])
        if "Par" in json_entry:
            entry = json_entry["Par"]
            par = entry["par_group"]
            component = entry["component"]
            # TODO: remove code clone
            calyx_pos_list: list[int] = list(
                filter(
                    lambda x: component_to_pos_to_loc_str is not None
                    and x in component_to_pos_to_loc_str[component],
                    entry["pos"],
                )
            )
            assert len(calyx_pos_list) <= 1
            if len(calyx_pos_list) == 1:
                # if we have a control position, look up its corresponding
                loc_str = component_to_pos_to_loc_str[component][calyx_pos_list[0]]
                control_metadata.component_to_ctrl_group_to_pos_str[component][par] = (
                    loc_str
                )

            child_par_groups = []
            for cell in cell_metadata.component_to_cells[component]:
                fully_qualified_par = ".".join((cell, par))
                for child in entry["child_groups"]:
                    child_name = child["group"]
                    if (
                        child_name
                        in control_metadata.component_to_par_groups[component]
                    ):  # child is a par
                        control_metadata.register_par_child(
                            component, child_name, par, ParChildType.PAR, cell_metadata
                        )
                        fully_qualified_child_name = ".".join((cell, child_name))
                        child_par_groups.append(fully_qualified_child_name)
                    else:  # normal group
                        control_metadata.register_par_child(
                            component,
                            child_name,
                            par,
                            ParChildType.GROUP,
                            cell_metadata,
                        )
                    # add par done register information
                    child_pd_reg = child["register"]
                    control_metadata.add_par_done_reg(
                        component, par, child_pd_reg, ".".join((cell, child_pd_reg))
                    )
                # add information to control_metadata
                control_metadata.register_fully_qualified_ctrl_gp(fully_qualified_par)

    return control_metadata


def read_enable_thread_json(enable_thread_json):
    """
    Returns the contents of the JSON file that maps enables to thread ids.
    """
    json_data = json.load(open(enable_thread_json))
    return json_data
