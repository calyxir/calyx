use num_bigint::BigUint;
use std::str::FromStr;

pub struct IntermediateRepresentation {
    pub sign: bool,
    pub mantissa: BigUint,
    pub exponent: i64,  // Arbitrary precision exponent
}

impl IntermediateRepresentation {
    // Function to create a NaN
    pub fn create_nan(bit_width: usize) -> Self {
        let exponent = (1 << (bit_width - 1)) - 1; // Max exponent for NaN
        let mantissa = BigUint::from(1u64); // Set least significant bit of mantissa
        IntermediateRepresentation {
            sign: false, // NaN is typically unsigned
            mantissa,
            exponent: exponent as i64,
        }
    }

    // Function to create infinity (positive or negative)
    pub fn create_infinity(sign: bool, bit_width: usize) -> Self {
        let exponent = (1 << (bit_width - 1)) - 1; // Max exponent for infinity
        let mantissa = BigUint::zero(); // Mantissa should be zero for infinity
        IntermediateRepresentation {
            sign,
            mantissa,
            exponent: exponent as i64,
        }
    }

    // Function to create a denormalized number
    pub fn create_denormalized(mantissa: BigUint) -> Self {
        IntermediateRepresentation {
            sign: false,  // Denormalized numbers are typically positive
            mantissa,
            exponent: 0,  // Exponent is zero for denormalized numbers
        }
    }

    // Function to create zero (positive or negative)
    pub fn create_zero(sign: bool) -> Self {
        IntermediateRepresentation {
            sign,
            mantissa: BigUint::zero(),
            exponent: 0,
        }
    }

    // Function to check if the value is NaN
    pub fn is_nan(&self, bit_width: usize) -> bool {
        let max_exponent_value = (1 << (bit_width - 1)) - 1; // Max exponent for NaN
        self.exponent == max_exponent_value as i64 && !self.mantissa.is_zero()
    }

    // Function to check if the value is infinity
    pub fn is_infinity(&self, bit_width: usize) -> bool {
        let max_exponent_value = (1 << (bit_width - 1)) - 1; // Max exponent for infinity
        self.exponent == max_exponent_value as i64 && self.mantissa.is_zero()
    }

    // Function to check if the value is denormalized
    pub fn is_denormalized(&self) -> bool {
        self.exponent == 0 && !self.mantissa.is_zero()
    }

    // Function to check if the value is zero
    pub fn is_zero(&self) -> bool {
        self.exponent == 0 && self.mantissa.is_zero()
    }

    // Function to create from binary string (updated with special cases handling)
    pub fn from_binary(
        binary_string: &str,
        bit_width: usize,
        twos_comp: bool,
    ) -> IntermediateRepresentation {
        let sign;
        if !twos_comp {
            sign = false;
        } else {
            sign = binary_string.starts_with('1');
        }

        let binary_value = BigUint::from_str_radix(binary_string, 2)
            .expect("Invalid binary string");

        let mantissa = if sign {
            // Calculate the two's complement for negative values
            let max_value = BigUint::from(1u64) << bit_width;
            &max_value - &binary_value
        } else {
            binary_value
        };

        let exponent = 0;  // For fixed-point or other representations, you may adjust this later

        IntermediateRepresentation {
            sign,
            mantissa,
            exponent,
        }
    }
}
