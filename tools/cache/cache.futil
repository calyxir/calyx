import "primitives/core.futil";
import "primitives/memories/comb.futil";
// COMPONENT START: main
component main() -> () {
  cells {
  }
  wires {
  }
  control {
    seq {
    }
  }
}
// COMPONENT END: main
// COMPONENT START: cache_level_L1
component cache_level_L1(read_en: 1, write_en: 1, in: 8, addr: 16, fetch_en: 1, fetch_in: 128) -> (out: 8, fetch_addr: 16) {
  cells {
    entries = comb_mem_d1(138, 64, 6);
    addr_to_index = std_bit_slice(16, 2, 8, 6);
    addr_to_tag = std_bit_slice(16, 8, 16, 8);
    entry_to_tag = std_bit_slice(138, 128, 136, 8);
    tag_matches = std_eq(8);
  }
  wires {
    // checks if the given `addr` exists in the cache
    comb group check_tag_matches {
      addr_to_index.in = addr;
      addr_to_tag.in = addr;
      entry_to_tag.in = entries.read_data;
      entries.addr0 = addr_to_index.out;
      tag_matches.left = addr_to_tag.out;
      tag_matches.right = entry_to_tag.out;
    }
    // we've cached this, so we can just look it up
    group read_cached {
    }
    // we need to ask the level below for this data
    group read_uncached {
    }
  }
  control {
    par {
      if read_en {
        if tag_matches.out with check_tag_matches {
          read_cached;
        } else {
          read_uncached;
        }
      } else {
      }
      if write_en {
      } else {
      }
    }
  }
}
// COMPONENT END: cache_level_L1

