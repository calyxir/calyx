//! Resource estimation backend for the Calyx compiler.
//! Transforms an [`ir::Context`](crate::ir::Context) into a CSV that
//! counts the number of different primitives in a program and loosely
//! estimates the total size of the generated hardware.

use std::io::Write;
use std::vec;
use std::{collections::HashMap, io};

use crate::backend::traits::Backend;
use calyx::ir::Component;
use calyx::{
    errors::CalyxResult,
    ir::{self, Binding, CellType, Id},
    utils::OutputFile,
};

#[derive(Default)]
pub struct ResourcesBackend;

impl Backend for ResourcesBackend {
    fn name(&self) -> &'static str {
        "resources"
    }

    /// OK to run this analysis on any Calyx program
    fn validate(_ctx: &ir::Context) -> CalyxResult<()> {
        Ok(())
    }

    /// Don't need to take care of this for this pass
    fn link_externs(
        _ctx: &ir::Context,
        _file: &mut OutputFile,
    ) -> CalyxResult<()> {
        Ok(())
    }

    fn emit(ctx: &ir::Context, file: &mut OutputFile) -> CalyxResult<()> {
        let main_comp = ctx
            .components
            .iter()
            .find(|comp| comp.name == ctx.entrypoint)
            .unwrap();

        let count_map: &mut HashMap<(Id, Binding), u32> = &mut HashMap::new();

        gen_count_map(ctx, main_comp, count_map);

        write_csv(count_map.clone(), file);

        estimated_size(count_map.clone());

        Ok(())
    }
}

/// Counts the number of each primitive with a given set of parameters
/// in the program with entrypoint `main_comp`.
/// TODO: handle multi-component designs
fn gen_count_map(
    ctx: &ir::Context,
    main_comp: &Component,
    count_map: &mut HashMap<(Id, Binding), u32>,
) {
    for cell in main_comp.cells.iter() {
        let cell_ref = cell.borrow();
        let primitives = vec![
            "std_reg",
            "std_mem_d1",
            "std_mem_d2",
            "std_mem_d3",
            "std_mem_d4",
            "seq_mem_d1",
            "seq_mem_d2",
            "seq_mem_d3",
            "seq_mem_d4",
        ];
        match &cell_ref.prototype {
            CellType::Primitive {
                name,
                param_binding,
                ..
            } => {
                if primitives.contains(&name.id.as_str()) {
                    *count_map
                        .entry((*name, (**param_binding).clone()))
                        .or_insert(0) += 1;
                }
            }
            CellType::Component { name } => {
                let component = ctx
                    .components
                    .iter()
                    .find(|comp| comp.name == name)
                    .unwrap();
                gen_count_map(ctx, component, count_map);
            }
            _ => (),
        }
    }
}

/// Writes a CSV to stdout with primitive count information
/// generated by `gen_count_map`.
/// TODO (priya): fix the output format and have it output to an actual file!
fn write_csv(count_map: HashMap<(Id, Binding), u32>, _file: &mut OutputFile) {
    let mut wtr = csv::Writer::from_writer(io::stdout());
    let header = vec!["Primitive", "Count", "Parameters"];
    wtr.write_record(header).ok();
    wtr.write_record(None::<&[u8]>).ok();
    for ((name, params), count) in count_map {
        let mut result = String::new();
        result.push_str(name.id.as_str());
        result.push(',');
        result.push_str(count.to_string().as_str());
        for (id, val) in params {
            result.push(',');
            result.push_str(id.id.as_str());
            result.push(',');
            result.push_str(val.to_string().as_str());
        }
        result.push('\n');
        let ret: Vec<&str> = result.split(',').collect();
        wtr.write_record(ret).ok();
    }
    wtr.flush().ok();
}

// Prints the estimated size (in bits) of the generated hardware along with a breakdown
// of which primitives contributed to the total number.
// TODO (priya): Add other primitives (need to discuss what reasonable size estimates are for them)
fn estimated_size(count_map: HashMap<(Id, Binding), u32>) {
    let mut estimated_size: u64 = 0;
    let out = &mut (Box::new(io::stdout()) as Box<dyn Write>);
    writeln!(out).ok();
    output("Summary of primitives:".to_string(), out);
    for ((name, params), count) in count_map {
        match name.as_ref() {
            "std_reg" => {
                estimated_size += (count as u64) * (params[0].1);
                let str = format!(
                    "{} {} primitive(s) with a bitwidth of {}.",
                    count, name, params[0].1
                );
                output(str, out);
            }
            "std_mem_d1" => {
                estimated_size += (count as u64) * (params[0].1 * params[1].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, params[1].1, params[0].1);
                output(str, out);
            }
            "std_mem_d2" => {
                estimated_size +=
                    (count as u64) * (params[0].1 * params[1].1 * params[2].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, (params[1].1 * params[2].1), params[0].1);
                output(str, out);
            }
            "std_mem_d3" => {
                estimated_size += (count as u64)
                    * (params[0].1 * params[1].1 * params[2].1 * params[3].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, (params[1].1 * params[2].1 * params[3].1), params[0].1);
                output(str, out);
            }
            "std_mem_d4" => {
                estimated_size += (count as u64)
                    * (params[0].1
                        * params[1].1
                        * params[2].1
                        * params[3].1
                        * params[4].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, (params[1].1 * params[2].1 * params[3].1 * params[4].1), params[0].1);
                output(str, out);
            }
            "seq_mem_d1" => {
                estimated_size += (count as u64) * (params[0].1 * params[1].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, params[1].1, params[0].1);
                output(str, out);
            }
            "seq_mem_d2" => {
                estimated_size +=
                    (count as u64) * (params[0].1 * params[1].1 * params[2].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, (params[1].1 * params[2].1), params[0].1);
                output(str, out);
            }
            "seq_mem_d3" => {
                estimated_size += (count as u64)
                    * (params[0].1 * params[1].1 * params[2].1 * params[3].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, (params[1].1 * params[2].1 * params[3].1), params[0].1);
                output(str, out);
            }
            "seq_mem_d4" => {
                estimated_size += (count as u64)
                    * (params[0].1
                        * params[1].1
                        * params[2].1
                        * params[3].1
                        * params[4].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, (params[1].1 * params[2].1 * params[3].1 * params[4].1), params[0].1);
                output(str, out);
            }
            _ => (),
        }
    }
    let str = format!("Estimated size in bit(s): {}", estimated_size);
    output(str, out);
}

fn output(str: String, out: &mut Box<dyn Write>) {
    out.write_all(str.as_bytes()).ok();
    writeln!(out).ok();
}
