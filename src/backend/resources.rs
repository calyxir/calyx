//! Resource estimation backend for the Calyx compiler.
//! Transforms an [`ir::Context`](crate::ir::Context) into a CSV that
//! counts the number of different primitives in a program and loosely
//! estimates the total size of the generated hardware.

use std::io::Write;
use std::vec;
use std::{collections::HashMap, io};

use crate::backend::traits::Backend;
use calyx::ir::Component;
use calyx::{
    errors::CalyxResult,
    ir::{self, Binding, CellType, Id},
    utils::OutputFile,
};

#[derive(Default)]
pub struct ResourcesBackend;

impl Backend for ResourcesBackend {
    fn name(&self) -> &'static str {
        "resources"
    }

    /// OK to run this analysis on any Calyx program
    fn validate(_ctx: &ir::Context) -> CalyxResult<()> {
        Ok(())
    }

    /// Don't need to take care of this for this pass
    fn link_externs(
        _ctx: &ir::Context,
        _file: &mut OutputFile,
    ) -> CalyxResult<()> {
        Ok(())
    }

    fn emit(ctx: &ir::Context, _file: &mut OutputFile) -> CalyxResult<()> {
        let main_comp = ctx
            .components
            .iter()
            .find(|comp| comp.name == ctx.entrypoint)
            .unwrap();

        let count_map: HashMap<(Id, Binding), u32> = gen_count_map(main_comp);

        write_csv(count_map.clone());

        estimated_size(count_map);

        Ok(())
    }
}

/// Counts the number of each primitive with a given set of parameters
/// in the program with entrypoint `main_comp`.
/// TODO: handle multi-component designs
fn gen_count_map(main_comp: &Component) -> HashMap<(Id, Binding), u32> {
    let mut count_map: HashMap<(Id, Binding), u32> = HashMap::new();
    for cell in main_comp.cells.iter() {
        let cell_ref = cell.borrow();
        match &cell_ref.prototype {
            CellType::Primitive {
                name,
                param_binding,
                ..
            } => match name {
                _ if name == "std_reg" => {
                    *count_map
                        .entry((Id::from("std_reg"), (**param_binding).clone()))
                        .or_insert(0) += 1
                }
                _ if name == "std_mem_d1" => {
                    *count_map
                        .entry((
                            Id::from("std_mem_d1"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "std_mem_d2" => {
                    *count_map
                        .entry((
                            Id::from("std_mem_d2"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "std_mem_d3" => {
                    *count_map
                        .entry((
                            Id::from("std_mem_d3"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "std_mem_d4" => {
                    *count_map
                        .entry((
                            Id::from("std_mem_d4"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "seq_mem_d1" => {
                    *count_map
                        .entry((
                            Id::from("seq_mem_d1"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "seq_mem_d2" => {
                    *count_map
                        .entry((
                            Id::from("seq_mem_d2"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "seq_mem_d3" => {
                    *count_map
                        .entry((
                            Id::from("seq_mem_d3"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ if name == "seq_mem_d4" => {
                    *count_map
                        .entry((
                            Id::from("seq_mem_d4"),
                            (**param_binding).clone(),
                        ))
                        .or_insert(0) += 1
                }
                _ => (),
            },
            CellType::Component { name: _name } => todo!(),
            _ => (),
        }
    }
    count_map
}

/// Writes a CSV to stdout with primitive count information
/// generated by `gen_count_map`.
/// TODO (priya): fix the output format and have it output to an actual file!
fn write_csv(count_map: HashMap<(Id, Binding), u32>) {
    let mut wtr = csv::Writer::from_writer(io::stdout());
    let header = vec!["Primitive", "Count", "Parameters"];
    wtr.write_record(header).ok();
    let mut result: Vec<u8> = vec![];
    for ((name, params), count) in count_map {
        result.append(&mut name.id.to_string().as_str().as_bytes().to_vec());
        result.append(&mut (", ").as_bytes().to_vec());
        result.append(&mut count.to_string().as_str().as_bytes().to_vec());
        result.append(&mut (", ").as_bytes().to_vec());
        for (id, val) in params {
            result.append(&mut id.id.to_string().into_bytes());
            result.append(&mut (", ").as_bytes().to_vec());
            result.append(&mut val.to_string().into_bytes());
            result.append(&mut (", ").as_bytes().to_vec());
        }
        result.append(&mut ("\n").as_bytes().to_vec());
        wtr.write_record([&result]).ok();
        result = vec![];
    }
    wtr.flush().ok();
}

// Prints the estimated size (in bits) of the generated hardware along with a breakdown
// of which primitives contributed to the total number.
// TODO (priya): Add other primitives (need to discuss what reasonable size estimates are for them)
fn estimated_size(count_map: HashMap<(Id, Binding), u32>) {
    let mut estimated_size: u64 = 0;
    let out = &mut (Box::new(io::stdout()) as Box<dyn Write>);
    output("Summary of primitives:".to_string(), out);
    for ((name, params), count) in count_map {
        match name {
            _ if name == "std_reg" => {
                estimated_size += (count as u64) * (params[0].1);
                let str = format!(
                    "{} {} primitive(s) with a bitwidth of {}.",
                    count, name, params[0].1
                );
                output(str, out);
            }
            _ if name == "std_mem_d1" => {
                estimated_size += (count as u64) * (params[0].1 * params[1].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, params[1].1, params[0].1);
                output(str, out);
            }
            _ if name == "std_mem_d2" => {
                estimated_size +=
                    (count as u64) * (params[0].1 * params[1].1 * params[2].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, (params[1].1 * params[2].1), params[0].1);
                output(str, out);
            }
            _ if name == "std_mem_d3" => {
                estimated_size += (count as u64)
                    * (params[0].1 * params[1].1 * params[2].1 * params[3].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, (params[1].1 * params[2].1 * params[3].1), params[0].1);
                output(str, out);
            }
            _ if name == "std_mem_d4" => {
                estimated_size += (count as u64)
                    * (params[0].1
                        * params[1].1
                        * params[2].1
                        * params[3].1
                        * params[4].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.", 
                    count, name, (params[1].1 * params[2].1 * params[3].1 * params[4].1), params[0].1);
                output(str, out);
            }
            _ if name == "seq_mem_d1" => {
                estimated_size += (count as u64) * (params[0].1 * params[1].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, params[1].1, params[0].1);
                output(str, out);
            }
            _ if name == "seq_mem_d2" => {
                estimated_size +=
                    (count as u64) * (params[0].1 * params[1].1 * params[2].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, (params[1].1 * params[2].1), params[0].1);
                output(str, out);
            }
            _ if name == "seq_mem_d3" => {
                estimated_size += (count as u64)
                    * (params[0].1 * params[1].1 * params[2].1 * params[3].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, (params[1].1 * params[2].1 * params[3].1), params[0].1);
                output(str, out);
            }
            _ if name == "seq_mem_d4" => {
                estimated_size += (count as u64)
                    * (params[0].1
                        * params[1].1
                        * params[2].1
                        * params[3].1
                        * params[4].1);
                let str = format!(
                    "{} {} primitive(s) with {} slot(s) of memory, each {} bit(s) wide.",
                     count, name, (params[1].1 * params[2].1 * params[3].1 * params[4].1), params[0].1);
                output(str, out);
            }
            _ => (),
        }
    }
    let str = format!("Estimated size in bit(s): {}", estimated_size);
    output(str, out);
}

fn output(str: String, out: &mut Box<dyn Write>) {
    out.write_all(str.as_bytes()).ok();
    writeln!(out).ok();
}
