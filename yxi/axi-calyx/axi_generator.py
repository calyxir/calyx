# NOTE: The `dynamic_axi_generator`, which wraps `dyn` memories, is much more up-to-date
# than this original axi generator which implement a read-compute-write sequence
# to get data in and out of the computational kernel.

# A partial list of things to update to get this working:
# 1. The cocotb AXI testbench expects the clk signal to be called `ap_clk`
# 2. The cocotb AXI testbench expects toplevel wires to start with a prefix of `m_axi_`
# 3. To interface correctly with Xilinx/XRT, we need to add subordinate axi controller logic from add_control_subordinate.py


from calyx.builder import (
    Builder,
    add_comp_ports,
    invoke,
    while_with,
    par,
    while_,
)
from typing import Literal
from math import log2, ceil
import json
import sys

from yxi_lib.axi_component import (
    add_bresp_channel,
    add_arread_channel,
    add_write_channel,
    add_read_channel,
    add_awwrite_channel,
)

# In general, ports to the wrapper are uppercase, internal registers are lower case.

# Since yxi is still young, keys and formatting change often.
width_key = "data_width"
size_key = "total_size"
name_key = "name"


# NOTE: Unlike the channel functions, this can expect multiple mems
def add_main_comp(prog, mems):
    wrapper_comp = prog.component("Toplevel")
    wrapper_comp.attribute("toplevel", 1)

    curr_addr_axi_par = []
    curr_addr_internal_par = []
    reads_par = []
    writes_par = []
    ref_mem_kwargs = {}

    # Create single main cell
    _main_compute = wrapper_comp.comp_instance(
        "main_compute", "main", check_undeclared=False
    )
    # Naming the clock signal `ap_clk` ensures Xilinx tool compatability
    wrapper_comp.input("ap_clk", 1, ["clk"])

    for mem in mems:
        mem_name = mem[name_key]

        # Get handles to be used later
        read_channel = prog.get_component(
            f"m_read_channel_{mem[width_key]}_{mem[size_key]}"
        )
        write_channel = prog.get_component(
            f"m_write_channel_{mem[width_key]}_{mem[size_key]}"
        )
        ar_channel = prog.get_component(
            f"m_ar_channel_{mem[width_key]}_{mem[size_key]}"
        )
        aw_channel = prog.get_component(
            f"m_aw_channel_{mem[width_key]}_{mem[size_key]}"
        )
        bresp_channel = prog.get_component(
            f"m_bresp_channel_{mem[width_key]}_{mem[size_key]}"
        )

        # These input/output names in the toplevel (i.e. 'm_axi_A0_ARREADY') need to match
        # the ports(not!! args) kernel.xml file generated by `xml_generator.py`.
        # We add the prefix `m_axi_` to maintain compatibility with the old verilog wrapper.
        # Once we deprecate the old wrapper we can probably remove this prefix here and modify `xml_generator.py`
        prefixed_mem_name = f"m_axi_{mem[name_key]}"
        # Inputs/Outputs
        wrapper_inputs = [
            (f"{prefixed_mem_name}_ARESETn", 1),
            (f"{prefixed_mem_name}_ARREADY", 1),
            (f"{prefixed_mem_name}_RVALID", 1),
            (f"{prefixed_mem_name}_RLAST", 1),
            (f"{prefixed_mem_name}_RDATA", mem[width_key]),
            (f"{prefixed_mem_name}_RRESP", 2),
            (f"{prefixed_mem_name}_AWREADY", 1),
            (f"{prefixed_mem_name}_WRESP", 2),
            (f"{prefixed_mem_name}_WREADY", 1),
            (f"{prefixed_mem_name}_BVALID", 1),
            # Only used for waveform tracing, not sent anywhere
            (f"{prefixed_mem_name}_BRESP", 2),
            # Only needed for coctb compatability, tied low
            (f"{prefixed_mem_name}_RID", 1),
        ]

        wrapper_outputs = [
            (f"{prefixed_mem_name}_ARVALID", 1),
            (f"{prefixed_mem_name}_ARADDR", 64),
            (f"{prefixed_mem_name}_ARSIZE", 3),
            (f"{prefixed_mem_name}_ARLEN", 8),
            (f"{prefixed_mem_name}_ARBURST", 2),
            (f"{prefixed_mem_name}_RREADY", 1),
            (f"{prefixed_mem_name}_AWVALID", 1),
            (f"{prefixed_mem_name}_AWADDR", 64),
            (f"{prefixed_mem_name}_AWSIZE", 3),
            (f"{prefixed_mem_name}_AWLEN", 8),
            (f"{prefixed_mem_name}_AWBURST", 2),
            (f"{prefixed_mem_name}_AWPROT", 3),
            (f"{prefixed_mem_name}_WVALID", 1),
            (f"{prefixed_mem_name}_WLAST", 1),
            (f"{prefixed_mem_name}_WDATA", mem[width_key]),
            (f"{prefixed_mem_name}_BREADY", 1),
            # ID signals are needed for coco compatability, tied low
            (f"{prefixed_mem_name}_ARID", 1),
            (f"{prefixed_mem_name}_AWID", 1),
            (f"{prefixed_mem_name}_WID", 1),
            (f"{prefixed_mem_name}_BID", 1),
        ]

        add_comp_ports(wrapper_comp, wrapper_inputs, wrapper_outputs)

        # Cells
        # Read stuff
        curr_addr_internal_mem = wrapper_comp.reg(
            clog2_or_1(mem[size_key]), f"curr_addr_internal_mem_{mem_name}"
        )
        curr_addr_axi = wrapper_comp.reg(64, f"curr_addr_axi_{mem_name}")

        wrapper_comp.cell(f"ar_channel_{mem_name}", ar_channel)
        wrapper_comp.cell(f"read_channel_{mem_name}", read_channel)

        # TODO: Don't think these need to be marked external, but we
        # we need to raise them at some point form original calyx program
        internal_mem = wrapper_comp.seq_mem_d1(
            name=f"internal_mem_{mem_name}",
            bitwidth=mem[width_key],
            len=mem[size_key],
            idx_size=clog2_or_1(mem[size_key]),
        )

        # Write stuff
        max_transfers = wrapper_comp.reg(8, f"max_transfers_{mem_name}")
        wrapper_comp.cell(f"aw_channel_{mem_name}", aw_channel)
        wrapper_comp.cell(f"write_channel_{mem_name}", write_channel)
        wrapper_comp.cell(f"bresp_channel_{mem_name}", bresp_channel)

        # Wires

        # Tie IDs low, needed for cocotb compatability. Not used anywhere
        with wrapper_comp.continuous:
            wrapper_comp.this()[f"{prefixed_mem_name}_ARID"] = 0
            wrapper_comp.this()[f"{prefixed_mem_name}_AWID"] = 0
            wrapper_comp.this()[f"{prefixed_mem_name}_WID"] = 0
            wrapper_comp.this()[f"{prefixed_mem_name}_BID"] = 0

        # No groups needed!

        # set up internal control blocks
        # TODO: turn these into parts of a par block
        this_component = wrapper_comp.this()

        ar_channel_invoke = invoke(
            # main_comp.get_cell(f"ar_channel_{mem_name}"),
            wrapper_comp.get_cell(f"ar_channel_{mem_name}"),
            ref_curr_addr_axi=curr_addr_axi,
            in_ARESETn=this_component[f"{prefixed_mem_name}_ARESETn"],
            in_ARREADY=this_component[f"{prefixed_mem_name}_ARREADY"],
            out_ARVALID=this_component[f"{prefixed_mem_name}_ARVALID"],
            out_ARADDR=this_component[f"{prefixed_mem_name}_ARADDR"],
            out_ARSIZE=this_component[f"{prefixed_mem_name}_ARSIZE"],
            out_ARLEN=this_component[f"{prefixed_mem_name}_ARLEN"],
            out_ARBURST=this_component[f"{prefixed_mem_name}_ARBURST"],
        )

        read_channel_invoke = invoke(
            wrapper_comp.get_cell(f"read_channel_{mem_name}"),
            ref_mem_ref=internal_mem,
            ref_curr_addr_internal_mem=curr_addr_internal_mem,
            ref_curr_addr_axi=curr_addr_axi,
            in_ARESETn=this_component[f"{prefixed_mem_name}_ARESETn"],
            in_RVALID=this_component[f"{prefixed_mem_name}_RVALID"],
            in_RLAST=this_component[f"{prefixed_mem_name}_RLAST"],
            in_RDATA=this_component[f"{prefixed_mem_name}_RDATA"],
            # TODO: Do we need this? Don't think this goes anywhere
            in_RRESP=this_component[f"{prefixed_mem_name}_RRESP"],
            out_RREADY=this_component[f"{prefixed_mem_name}_RREADY"],
        )

        aw_channel_invoke = invoke(
            wrapper_comp.get_cell(f"aw_channel_{mem_name}"),
            ref_curr_addr_axi=curr_addr_axi,
            ref_max_transfers=max_transfers,
            in_ARESETn=this_component[f"{prefixed_mem_name}_ARESETn"],
            in_AWREADY=this_component[f"{prefixed_mem_name}_AWREADY"],
            out_AWVALID=this_component[f"{prefixed_mem_name}_AWVALID"],
            out_AWADDR=this_component[f"{prefixed_mem_name}_AWADDR"],
            out_AWSIZE=this_component[f"{prefixed_mem_name}_AWSIZE"],
            out_AWLEN=this_component[f"{prefixed_mem_name}_AWLEN"],
            out_AWBURST=this_component[f"{prefixed_mem_name}_AWBURST"],
            out_AWPROT=this_component[f"{prefixed_mem_name}_AWPROT"],
        )

        write_channel_invoke = invoke(
            wrapper_comp.get_cell(f"write_channel_{mem_name}"),
            ref_mem_ref=internal_mem,
            ref_curr_addr_internal_mem=curr_addr_internal_mem,
            ref_curr_addr_axi=curr_addr_axi,
            ref_max_transfers=max_transfers,
            in_ARESETn=this_component[f"{prefixed_mem_name}_ARESETn"],
            in_WREADY=this_component[f"{prefixed_mem_name}_WREADY"],
            out_WVALID=this_component[f"{prefixed_mem_name}_WVALID"],
            out_WLAST=this_component[f"{prefixed_mem_name}_WLAST"],
            out_WDATA=this_component[f"{prefixed_mem_name}_WDATA"],
        )

        bresp_channel_invoke = invoke(
            wrapper_comp.get_cell(f"bresp_channel_{mem_name}"),
            in_BVALID=this_component[f"{prefixed_mem_name}_BVALID"],
            out_BREADY=this_component[f"{prefixed_mem_name}_BREADY"],
        )

        curr_addr_axi_invoke = invoke(curr_addr_axi, in_in=0x1000)
        curr_addr_internal_invoke = invoke(curr_addr_internal_mem, in_in=0x0000)

        curr_addr_axi_par.append(curr_addr_axi_invoke)
        curr_addr_internal_par.append(curr_addr_internal_invoke)
        reads_par.append([ar_channel_invoke, read_channel_invoke])
        writes_par.append(
            [
                aw_channel_invoke,
                write_channel_invoke,
                bresp_channel_invoke,
            ]
        )
        # Creates `<mem_name> = internal_mem_<mem_name>` as refs in invocation of `main_compute`
        ref_mem_kwargs[f"ref_{mem_name}"] = internal_mem

    # Compute invoke
    # Assumes refs should be of form `<mem_name> = internal_mem_<mem_name>`
    main_compute_invoke = invoke(
        wrapper_comp.get_cell("main_compute"), **ref_mem_kwargs
    )

    # Compiler should reschedule these 2 seqs to be in parallel right?
    wrapper_comp.control += par(*curr_addr_axi_par)
    wrapper_comp.control += par(*curr_addr_internal_par)

    wrapper_comp.control += par(*reads_par)
    wrapper_comp.control += main_compute_invoke
    # Reset axi adress to 0
    wrapper_comp.control += par(*curr_addr_axi_par)
    wrapper_comp.control += par(*writes_par)


# Helper functions
def width_in_bytes(width: int):
    assert width % 8 == 0, "Width must be a multiple of 8."
    return width // 8


def width_xsize(width: int):
    log = log2(width_in_bytes(width))
    assert log.is_integer(), "Width must be a power of 2."
    return int(log)


def clog2(x):
    """Ceiling log2"""
    if x <= 0:
        raise ValueError("x must be positive")
    return (x - 1).bit_length()


def clog2_or_1(x):
    """Ceiling log2 or 1 if clog2(x) == 0"""
    return max(1, clog2(x))


def build():
    prog = Builder(emit_sourceloc=False)
    check_mems_welformed(mems)
    memsizes = []
    for mem in mems:
        nwidth = mem[width_key]
        nlen = mem[size_key]
        if (nwidth, nlen) not in memsizes:
            add_arread_channel(prog, nwidth, nlen)
            add_awwrite_channel(prog, nwidth, nlen)
            add_read_channel(prog, nwidth, nlen)
            add_write_channel(prog, nwidth, nlen)
            add_bresp_channel(prog, nwidth, nlen)
            memsizes.append((nwidth, nlen))
    add_main_comp(prog, mems)
    return prog.program


# TODO: check that width corresponds to size
def check_mems_welformed(mems):
    """Checks if memories from yxi are well formed. Returns true if they are, false otherwise."""
    for mem in mems:
        assert mem[width_key] % 8 == 0, (
            "Width must be a multiple of 8 to allow byte addressing to host"
        )
        assert log2(mem[width_key]).is_integer(), (
            "Width must be a power of 2 to be correctly described by xSIZE"
        )
        assert mem[size_key] > 0, "Memory size must be greater than 0"


if __name__ == "__main__":
    yxifilename = "input.yxi"  # default
    if len(sys.argv) > 2:
        raise Exception("axi generator takes 1 yxi file name as argument")
    else:
        try:
            yxifilename = sys.argv[1]
            if not yxifilename.endswith(".yxi"):
                raise Exception("axi generator requires an yxi file")
        except Exception:
            pass  # no arg passed
    with open(yxifilename, "r", encoding="utf-8") as yxifile:
        yxifile = open(yxifilename)
        yxi = json.load(yxifile)
        mems = yxi["memories"]
        build().emit()
