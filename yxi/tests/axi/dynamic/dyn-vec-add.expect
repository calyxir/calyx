import "primitives/core.futil";
import "primitives/binary_operators.futil";
import "primitives/memories/dyn.futil";
component m_ar_channel_A0<"pos"={0}>(ARESETn: 1, ARREADY: 1, axi_address: 64) -> (ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3) {
  cells {
    @pos{1} arvalid = std_reg(1);
    @pos{2} ar_handshake_occurred = std_reg(1);
    @pos{3} bt_reg = std_reg(1);
  }
  wires {
    ARVALID = arvalid.out;
    group do_ar_transfer<"pos"={4}> {
      arvalid.in = (!(arvalid.out & ARREADY) & !ar_handshake_occurred.out) ? 1'd1;
      arvalid.in = ((arvalid.out & ARREADY) | ar_handshake_occurred.out) ? 1'd0;
      arvalid.write_en = 1'd1;
      ar_handshake_occurred.in = (arvalid.out & ARREADY) ? 1'd1;
      ar_handshake_occurred.write_en = !ar_handshake_occurred.out ? 1'd1;
      ARADDR = axi_address;
      ARSIZE = 3'd2;
      ARLEN = 8'd0;
      ARBURST = 2'd1;
      ARPROT = 3'd6;
      bt_reg.in = (ARREADY & arvalid.out) ? 1'd1;
      bt_reg.in = !(ARREADY & arvalid.out) ? 1'd0;
      bt_reg.write_en = 1'd1;
      do_ar_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{9} seq {
      @pos{7} par {
        @pos{5} invoke bt_reg(in=1'd0)();
        @pos{6} invoke ar_handshake_occurred(in=1'd0)();
      }
      @pos{9} do_ar_transfer;
      @pos{8} invoke arvalid(in=1'd0)();
    }
  }
}
component m_aw_channel_A0<"pos"={0}>(ARESETn: 1, AWREADY: 1, axi_address: 64) -> (AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3) {
  cells {
    @pos{1} awvalid = std_reg(1);
    @pos{2} aw_handshake_occurred = std_reg(1);
    @pos{3} bt_reg = std_reg(1);
  }
  wires {
    AWVALID = awvalid.out;
    group do_aw_transfer<"pos"={4}> {
      awvalid.in = (!(awvalid.out & AWREADY) & !aw_handshake_occurred.out) ? 1'd1;
      awvalid.in = ((awvalid.out & AWREADY) | aw_handshake_occurred.out) ? 1'd0;
      awvalid.write_en = 1'd1;
      aw_handshake_occurred.in = (awvalid.out & AWREADY) ? 1'd1;
      aw_handshake_occurred.write_en = !aw_handshake_occurred.out ? 1'd1;
      AWADDR = axi_address;
      AWSIZE = 3'd2;
      AWLEN = 8'd0;
      AWBURST = 2'd1;
      AWPROT = 3'd6;
      bt_reg.in = (AWREADY & awvalid.out) ? 1'd1;
      bt_reg.in = !(AWREADY & awvalid.out) ? 1'd0;
      bt_reg.write_en = 1'd1;
      do_aw_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{9} seq {
      @pos{7} par {
        @pos{5} invoke bt_reg(in=1'd0)();
        @pos{6} invoke aw_handshake_occurred(in=1'd0)();
      }
      @pos{9} do_aw_transfer;
      @pos{8} invoke awvalid(in=1'd0)();
    }
  }
}
component m_read_channel_A0<"pos"={10}>(ARESETn: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2) -> (RREADY: 1, read_data: 32) {
  cells {
    @pos{11} read_reg = std_reg(32);
    @pos{12} rready = std_reg(1);
    @pos{13} n_RLAST = std_reg(1);
  }
  wires {
    RREADY = rready.out;
    read_data = read_reg.out;
    group block_transfer<"pos"={14}> {
      rready.in = !(rready.out & RVALID) ? 1'd1;
      rready.in = (rready.out & RVALID) ? 1'd0;
      rready.write_en = 1'd1;
      read_reg.in = RDATA;
      read_reg.write_en = (rready.out & RVALID) ? 1'd1;
      read_reg.write_en = !(rready.out & RVALID) ? 1'd0;
      n_RLAST.in = RLAST ? 1'd0;
      n_RLAST.in = !RLAST ? 1'd1;
      n_RLAST.write_en = 1'd1;
      block_transfer[done] = read_reg.done;
    }
  }
  control {
    @pos{17} seq {
      @pos{15} invoke n_RLAST(in=1'd1)();
      @pos{16} while n_RLAST.out {
        @pos{16} seq {
          @pos{16} block_transfer;
        }
      }
    }
  }
}
component m_write_channel_A0<"pos"={18}>(ARESETn: 1, WREADY: 1, write_data: 32) -> (WVALID: 1, WLAST: 1, WDATA: 32) {
  cells {
    @pos{19} wvalid = std_reg(1);
    @pos{20} w_handshake_occurred = std_reg(1);
    @pos{21} bt_reg = std_reg(1);
  }
  wires {
    WVALID = wvalid.out;
    group service_write_transfer<"pos"={22}> {
      wvalid.in = (!(wvalid.out & WREADY) & !w_handshake_occurred.out) ? 1'd1;
      wvalid.in = ((wvalid.out & WREADY) | w_handshake_occurred.out) ? 1'd0;
      wvalid.write_en = 1'd1;
      w_handshake_occurred.in = (wvalid.out & WREADY) ? 1'd1;
      w_handshake_occurred.in = !(wvalid.out & WREADY) ? 1'd0;
      w_handshake_occurred.write_en = !w_handshake_occurred.out ? 1'd1;
      WDATA = write_data;
      WLAST = 1'd1;
      bt_reg.in = (wvalid.out & WREADY) ? 1'd1;
      bt_reg.in = !(wvalid.out & WREADY) ? 1'd0;
      bt_reg.write_en = 1'd1;
      service_write_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{25} seq {
      @pos{23} invoke bt_reg(in=1'd0)();
      @pos{24} invoke w_handshake_occurred(in=1'd0)();
      @pos{25} service_write_transfer;
    }
  }
}
component m_bresp_channel_A0<"pos"={26}>(ARESETn: 1, BVALID: 1) -> (BREADY: 1) {
  cells {
    @pos{27} bready = std_reg(1);
    @pos{28} bt_reg = std_reg(1);
  }
  wires {
    BREADY = bready.out;
    group block_transfer<"pos"={29}> {
      bready.in = !(bready.out & BVALID) ? 1'd1;
      bready.in = (bready.out & BVALID) ? 1'd0;
      bready.write_en = 1'd1;
      bt_reg.in = (bready.out & BVALID) ? 1'd1;
      bt_reg.in = !(bready.out & BVALID) ? 1'd0;
      bt_reg.write_en = 1'd1;
      block_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{30} seq {
      @pos{30} invoke bt_reg(in=1'd0)();
      @pos{30} block_transfer;
    }
  }
}
comb component address_translator_A0(calyx_mem_addr: 3) -> (axi_address: 64) {
  cells {
    @pos{31} mul_A0 = std_const_mult(64, 4);
    @pos{32} pad_input_addr = std_pad(3, 64);
  }
  wires {
    pad_input_addr.in = calyx_mem_addr;
    mul_A0.in = pad_input_addr.out;
    axi_address = mul_A0.out;
  }
}
component read_controller_A0<"pos"={33}>(axi_address: 64, ARESETn: 1, ARREADY: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2) -> (ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3, RREADY: 1, read_data: 32) {
  cells {
    @pos{34} ar_channel_A0 = m_ar_channel_A0();
    @pos{35} read_channel_A0 = m_read_channel_A0();
  }
  wires {
    read_data = read_channel_A0.read_data;
  }
  control {
    @pos{38} seq {
      @pos{36} invoke ar_channel_A0(axi_address=axi_address, ARESETn=ARESETn, ARREADY=ARREADY)(ARVALID=ARVALID, ARADDR=ARADDR, ARSIZE=ARSIZE, ARLEN=ARLEN, ARBURST=ARBURST, ARPROT=ARPROT);
      @pos{37} invoke read_channel_A0(ARESETn=ARESETn, RVALID=RVALID, RLAST=RLAST, RDATA=RDATA, RRESP=RRESP)(RREADY=RREADY);
    }
  }
}
component write_controller_A0<"pos"={39}>(axi_address: 64, write_data: 32, ARESETn: 1, AWREADY: 1, WREADY: 1, BVALID: 1) -> (AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3, WVALID: 1, WLAST: 1, WDATA: 32, BREADY: 1) {
  cells {
    @pos{40} aw_channel_A0 = m_aw_channel_A0();
    @pos{41} write_channel_A0 = m_write_channel_A0();
    @pos{42} bresp_channel_A0 = m_bresp_channel_A0();
  }
  wires {

  }
  control {
    @pos{46} seq {
      @pos{43} invoke aw_channel_A0(axi_address=axi_address, ARESETn=ARESETn, AWREADY=AWREADY)(AWVALID=AWVALID, AWADDR=AWADDR, AWSIZE=AWSIZE, AWLEN=AWLEN, AWBURST=AWBURST, AWPROT=AWPROT);
      @pos{44} invoke write_channel_A0(write_data=write_data, ARESETn=ARESETn, WREADY=WREADY)(WVALID=WVALID, WLAST=WLAST, WDATA=WDATA);
      @pos{45} invoke bresp_channel_A0(BVALID=BVALID)(BREADY=BREADY);
    }
  }
}
component axi_dyn_mem_A0<"pos"={47}>(@data @write_together(1) addr0: 3, @go(1) @write_together(1) content_en: 1, @write_together(2) write_en: 1, @data @write_together(2) write_data: 32, ARESETn: 1, ARREADY: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2, AWREADY: 1, WREADY: 1, BVALID: 1, BRESP: 2) -> (@stable read_data: 32, ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3, RREADY: 1, AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3, WVALID: 1, WLAST: 1, WDATA: 32, BREADY: 1) {
  cells {
    @pos{48} address_translator_A0 = address_translator_A0();
    @pos{49} read_controller_A0 = read_controller_A0();
    @pos{50} write_controller_A0 = write_controller_A0();
  }
  wires {
    address_translator_A0.calyx_mem_addr = addr0;
    read_data = read_controller_A0.read_data;
  }
  control {
    @pos{54} seq {
      @pos{53} if write_en {
        @pos{52} invoke write_controller_A0(axi_address=address_translator_A0.axi_address, write_data=write_data, ARESETn=ARESETn, AWREADY=AWREADY, WREADY=WREADY, BVALID=BVALID)(AWVALID=AWVALID, AWADDR=AWADDR, AWSIZE=AWSIZE, AWLEN=AWLEN, AWBURST=AWBURST, AWPROT=AWPROT, WVALID=WVALID, WLAST=WLAST, WDATA=WDATA, BREADY=BREADY);
      } else {
        @pos{51} invoke read_controller_A0(axi_address=address_translator_A0.axi_address, ARESETn=ARESETn, ARREADY=ARREADY, RVALID=RVALID, RLAST=RLAST, RDATA=RDATA, RRESP=RRESP)(ARVALID=ARVALID, ARADDR=ARADDR, ARSIZE=ARSIZE, ARLEN=ARLEN, ARBURST=ARBURST, ARPROT=ARPROT, RREADY=RREADY, read_data=read_data);
      }
    }
  }
}
component m_ar_channel_B0<"pos"={0}>(ARESETn: 1, ARREADY: 1, axi_address: 64) -> (ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3) {
  cells {
    @pos{1} arvalid = std_reg(1);
    @pos{2} ar_handshake_occurred = std_reg(1);
    @pos{3} bt_reg = std_reg(1);
  }
  wires {
    ARVALID = arvalid.out;
    group do_ar_transfer<"pos"={4}> {
      arvalid.in = (!(arvalid.out & ARREADY) & !ar_handshake_occurred.out) ? 1'd1;
      arvalid.in = ((arvalid.out & ARREADY) | ar_handshake_occurred.out) ? 1'd0;
      arvalid.write_en = 1'd1;
      ar_handshake_occurred.in = (arvalid.out & ARREADY) ? 1'd1;
      ar_handshake_occurred.write_en = !ar_handshake_occurred.out ? 1'd1;
      ARADDR = axi_address;
      ARSIZE = 3'd2;
      ARLEN = 8'd0;
      ARBURST = 2'd1;
      ARPROT = 3'd6;
      bt_reg.in = (ARREADY & arvalid.out) ? 1'd1;
      bt_reg.in = !(ARREADY & arvalid.out) ? 1'd0;
      bt_reg.write_en = 1'd1;
      do_ar_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{9} seq {
      @pos{7} par {
        @pos{5} invoke bt_reg(in=1'd0)();
        @pos{6} invoke ar_handshake_occurred(in=1'd0)();
      }
      @pos{9} do_ar_transfer;
      @pos{8} invoke arvalid(in=1'd0)();
    }
  }
}
component m_aw_channel_B0<"pos"={0}>(ARESETn: 1, AWREADY: 1, axi_address: 64) -> (AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3) {
  cells {
    @pos{1} awvalid = std_reg(1);
    @pos{2} aw_handshake_occurred = std_reg(1);
    @pos{3} bt_reg = std_reg(1);
  }
  wires {
    AWVALID = awvalid.out;
    group do_aw_transfer<"pos"={4}> {
      awvalid.in = (!(awvalid.out & AWREADY) & !aw_handshake_occurred.out) ? 1'd1;
      awvalid.in = ((awvalid.out & AWREADY) | aw_handshake_occurred.out) ? 1'd0;
      awvalid.write_en = 1'd1;
      aw_handshake_occurred.in = (awvalid.out & AWREADY) ? 1'd1;
      aw_handshake_occurred.write_en = !aw_handshake_occurred.out ? 1'd1;
      AWADDR = axi_address;
      AWSIZE = 3'd2;
      AWLEN = 8'd0;
      AWBURST = 2'd1;
      AWPROT = 3'd6;
      bt_reg.in = (AWREADY & awvalid.out) ? 1'd1;
      bt_reg.in = !(AWREADY & awvalid.out) ? 1'd0;
      bt_reg.write_en = 1'd1;
      do_aw_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{9} seq {
      @pos{7} par {
        @pos{5} invoke bt_reg(in=1'd0)();
        @pos{6} invoke aw_handshake_occurred(in=1'd0)();
      }
      @pos{9} do_aw_transfer;
      @pos{8} invoke awvalid(in=1'd0)();
    }
  }
}
component m_read_channel_B0<"pos"={10}>(ARESETn: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2) -> (RREADY: 1, read_data: 32) {
  cells {
    @pos{11} read_reg = std_reg(32);
    @pos{12} rready = std_reg(1);
    @pos{13} n_RLAST = std_reg(1);
  }
  wires {
    RREADY = rready.out;
    read_data = read_reg.out;
    group block_transfer<"pos"={14}> {
      rready.in = !(rready.out & RVALID) ? 1'd1;
      rready.in = (rready.out & RVALID) ? 1'd0;
      rready.write_en = 1'd1;
      read_reg.in = RDATA;
      read_reg.write_en = (rready.out & RVALID) ? 1'd1;
      read_reg.write_en = !(rready.out & RVALID) ? 1'd0;
      n_RLAST.in = RLAST ? 1'd0;
      n_RLAST.in = !RLAST ? 1'd1;
      n_RLAST.write_en = 1'd1;
      block_transfer[done] = read_reg.done;
    }
  }
  control {
    @pos{17} seq {
      @pos{15} invoke n_RLAST(in=1'd1)();
      @pos{16} while n_RLAST.out {
        @pos{16} seq {
          @pos{16} block_transfer;
        }
      }
    }
  }
}
component m_write_channel_B0<"pos"={18}>(ARESETn: 1, WREADY: 1, write_data: 32) -> (WVALID: 1, WLAST: 1, WDATA: 32) {
  cells {
    @pos{19} wvalid = std_reg(1);
    @pos{20} w_handshake_occurred = std_reg(1);
    @pos{21} bt_reg = std_reg(1);
  }
  wires {
    WVALID = wvalid.out;
    group service_write_transfer<"pos"={22}> {
      wvalid.in = (!(wvalid.out & WREADY) & !w_handshake_occurred.out) ? 1'd1;
      wvalid.in = ((wvalid.out & WREADY) | w_handshake_occurred.out) ? 1'd0;
      wvalid.write_en = 1'd1;
      w_handshake_occurred.in = (wvalid.out & WREADY) ? 1'd1;
      w_handshake_occurred.in = !(wvalid.out & WREADY) ? 1'd0;
      w_handshake_occurred.write_en = !w_handshake_occurred.out ? 1'd1;
      WDATA = write_data;
      WLAST = 1'd1;
      bt_reg.in = (wvalid.out & WREADY) ? 1'd1;
      bt_reg.in = !(wvalid.out & WREADY) ? 1'd0;
      bt_reg.write_en = 1'd1;
      service_write_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{25} seq {
      @pos{23} invoke bt_reg(in=1'd0)();
      @pos{24} invoke w_handshake_occurred(in=1'd0)();
      @pos{25} service_write_transfer;
    }
  }
}
component m_bresp_channel_B0<"pos"={26}>(ARESETn: 1, BVALID: 1) -> (BREADY: 1) {
  cells {
    @pos{27} bready = std_reg(1);
    @pos{28} bt_reg = std_reg(1);
  }
  wires {
    BREADY = bready.out;
    group block_transfer<"pos"={29}> {
      bready.in = !(bready.out & BVALID) ? 1'd1;
      bready.in = (bready.out & BVALID) ? 1'd0;
      bready.write_en = 1'd1;
      bt_reg.in = (bready.out & BVALID) ? 1'd1;
      bt_reg.in = !(bready.out & BVALID) ? 1'd0;
      bt_reg.write_en = 1'd1;
      block_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{30} seq {
      @pos{30} invoke bt_reg(in=1'd0)();
      @pos{30} block_transfer;
    }
  }
}
comb component address_translator_B0(calyx_mem_addr: 3) -> (axi_address: 64) {
  cells {
    @pos{31} mul_B0 = std_const_mult(64, 4);
    @pos{32} pad_input_addr = std_pad(3, 64);
  }
  wires {
    pad_input_addr.in = calyx_mem_addr;
    mul_B0.in = pad_input_addr.out;
    axi_address = mul_B0.out;
  }
}
component read_controller_B0<"pos"={33}>(axi_address: 64, ARESETn: 1, ARREADY: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2) -> (ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3, RREADY: 1, read_data: 32) {
  cells {
    @pos{34} ar_channel_B0 = m_ar_channel_B0();
    @pos{35} read_channel_B0 = m_read_channel_B0();
  }
  wires {
    read_data = read_channel_B0.read_data;
  }
  control {
    @pos{38} seq {
      @pos{36} invoke ar_channel_B0(axi_address=axi_address, ARESETn=ARESETn, ARREADY=ARREADY)(ARVALID=ARVALID, ARADDR=ARADDR, ARSIZE=ARSIZE, ARLEN=ARLEN, ARBURST=ARBURST, ARPROT=ARPROT);
      @pos{37} invoke read_channel_B0(ARESETn=ARESETn, RVALID=RVALID, RLAST=RLAST, RDATA=RDATA, RRESP=RRESP)(RREADY=RREADY);
    }
  }
}
component write_controller_B0<"pos"={39}>(axi_address: 64, write_data: 32, ARESETn: 1, AWREADY: 1, WREADY: 1, BVALID: 1) -> (AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3, WVALID: 1, WLAST: 1, WDATA: 32, BREADY: 1) {
  cells {
    @pos{40} aw_channel_B0 = m_aw_channel_B0();
    @pos{41} write_channel_B0 = m_write_channel_B0();
    @pos{42} bresp_channel_B0 = m_bresp_channel_B0();
  }
  wires {

  }
  control {
    @pos{46} seq {
      @pos{43} invoke aw_channel_B0(axi_address=axi_address, ARESETn=ARESETn, AWREADY=AWREADY)(AWVALID=AWVALID, AWADDR=AWADDR, AWSIZE=AWSIZE, AWLEN=AWLEN, AWBURST=AWBURST, AWPROT=AWPROT);
      @pos{44} invoke write_channel_B0(write_data=write_data, ARESETn=ARESETn, WREADY=WREADY)(WVALID=WVALID, WLAST=WLAST, WDATA=WDATA);
      @pos{45} invoke bresp_channel_B0(BVALID=BVALID)(BREADY=BREADY);
    }
  }
}
component axi_dyn_mem_B0<"pos"={47}>(@data @write_together(1) addr0: 3, @go(1) @write_together(1) content_en: 1, @write_together(2) write_en: 1, @data @write_together(2) write_data: 32, ARESETn: 1, ARREADY: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2, AWREADY: 1, WREADY: 1, BVALID: 1, BRESP: 2) -> (@stable read_data: 32, ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3, RREADY: 1, AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3, WVALID: 1, WLAST: 1, WDATA: 32, BREADY: 1) {
  cells {
    @pos{48} address_translator_B0 = address_translator_B0();
    @pos{49} read_controller_B0 = read_controller_B0();
    @pos{50} write_controller_B0 = write_controller_B0();
  }
  wires {
    address_translator_B0.calyx_mem_addr = addr0;
    read_data = read_controller_B0.read_data;
  }
  control {
    @pos{54} seq {
      @pos{53} if write_en {
        @pos{52} invoke write_controller_B0(axi_address=address_translator_B0.axi_address, write_data=write_data, ARESETn=ARESETn, AWREADY=AWREADY, WREADY=WREADY, BVALID=BVALID)(AWVALID=AWVALID, AWADDR=AWADDR, AWSIZE=AWSIZE, AWLEN=AWLEN, AWBURST=AWBURST, AWPROT=AWPROT, WVALID=WVALID, WLAST=WLAST, WDATA=WDATA, BREADY=BREADY);
      } else {
        @pos{51} invoke read_controller_B0(axi_address=address_translator_B0.axi_address, ARESETn=ARESETn, ARREADY=ARREADY, RVALID=RVALID, RLAST=RLAST, RDATA=RDATA, RRESP=RRESP)(ARVALID=ARVALID, ARADDR=ARADDR, ARSIZE=ARSIZE, ARLEN=ARLEN, ARBURST=ARBURST, ARPROT=ARPROT, RREADY=RREADY, read_data=read_data);
      }
    }
  }
}
component m_ar_channel_Sum0<"pos"={0}>(ARESETn: 1, ARREADY: 1, axi_address: 64) -> (ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3) {
  cells {
    @pos{1} arvalid = std_reg(1);
    @pos{2} ar_handshake_occurred = std_reg(1);
    @pos{3} bt_reg = std_reg(1);
  }
  wires {
    ARVALID = arvalid.out;
    group do_ar_transfer<"pos"={4}> {
      arvalid.in = (!(arvalid.out & ARREADY) & !ar_handshake_occurred.out) ? 1'd1;
      arvalid.in = ((arvalid.out & ARREADY) | ar_handshake_occurred.out) ? 1'd0;
      arvalid.write_en = 1'd1;
      ar_handshake_occurred.in = (arvalid.out & ARREADY) ? 1'd1;
      ar_handshake_occurred.write_en = !ar_handshake_occurred.out ? 1'd1;
      ARADDR = axi_address;
      ARSIZE = 3'd2;
      ARLEN = 8'd0;
      ARBURST = 2'd1;
      ARPROT = 3'd6;
      bt_reg.in = (ARREADY & arvalid.out) ? 1'd1;
      bt_reg.in = !(ARREADY & arvalid.out) ? 1'd0;
      bt_reg.write_en = 1'd1;
      do_ar_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{9} seq {
      @pos{7} par {
        @pos{5} invoke bt_reg(in=1'd0)();
        @pos{6} invoke ar_handshake_occurred(in=1'd0)();
      }
      @pos{9} do_ar_transfer;
      @pos{8} invoke arvalid(in=1'd0)();
    }
  }
}
component m_aw_channel_Sum0<"pos"={0}>(ARESETn: 1, AWREADY: 1, axi_address: 64) -> (AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3) {
  cells {
    @pos{1} awvalid = std_reg(1);
    @pos{2} aw_handshake_occurred = std_reg(1);
    @pos{3} bt_reg = std_reg(1);
  }
  wires {
    AWVALID = awvalid.out;
    group do_aw_transfer<"pos"={4}> {
      awvalid.in = (!(awvalid.out & AWREADY) & !aw_handshake_occurred.out) ? 1'd1;
      awvalid.in = ((awvalid.out & AWREADY) | aw_handshake_occurred.out) ? 1'd0;
      awvalid.write_en = 1'd1;
      aw_handshake_occurred.in = (awvalid.out & AWREADY) ? 1'd1;
      aw_handshake_occurred.write_en = !aw_handshake_occurred.out ? 1'd1;
      AWADDR = axi_address;
      AWSIZE = 3'd2;
      AWLEN = 8'd0;
      AWBURST = 2'd1;
      AWPROT = 3'd6;
      bt_reg.in = (AWREADY & awvalid.out) ? 1'd1;
      bt_reg.in = !(AWREADY & awvalid.out) ? 1'd0;
      bt_reg.write_en = 1'd1;
      do_aw_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{9} seq {
      @pos{7} par {
        @pos{5} invoke bt_reg(in=1'd0)();
        @pos{6} invoke aw_handshake_occurred(in=1'd0)();
      }
      @pos{9} do_aw_transfer;
      @pos{8} invoke awvalid(in=1'd0)();
    }
  }
}
component m_read_channel_Sum0<"pos"={10}>(ARESETn: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2) -> (RREADY: 1, read_data: 32) {
  cells {
    @pos{11} read_reg = std_reg(32);
    @pos{12} rready = std_reg(1);
    @pos{13} n_RLAST = std_reg(1);
  }
  wires {
    RREADY = rready.out;
    read_data = read_reg.out;
    group block_transfer<"pos"={14}> {
      rready.in = !(rready.out & RVALID) ? 1'd1;
      rready.in = (rready.out & RVALID) ? 1'd0;
      rready.write_en = 1'd1;
      read_reg.in = RDATA;
      read_reg.write_en = (rready.out & RVALID) ? 1'd1;
      read_reg.write_en = !(rready.out & RVALID) ? 1'd0;
      n_RLAST.in = RLAST ? 1'd0;
      n_RLAST.in = !RLAST ? 1'd1;
      n_RLAST.write_en = 1'd1;
      block_transfer[done] = read_reg.done;
    }
  }
  control {
    @pos{17} seq {
      @pos{15} invoke n_RLAST(in=1'd1)();
      @pos{16} while n_RLAST.out {
        @pos{16} seq {
          @pos{16} block_transfer;
        }
      }
    }
  }
}
component m_write_channel_Sum0<"pos"={18}>(ARESETn: 1, WREADY: 1, write_data: 32) -> (WVALID: 1, WLAST: 1, WDATA: 32) {
  cells {
    @pos{19} wvalid = std_reg(1);
    @pos{20} w_handshake_occurred = std_reg(1);
    @pos{21} bt_reg = std_reg(1);
  }
  wires {
    WVALID = wvalid.out;
    group service_write_transfer<"pos"={22}> {
      wvalid.in = (!(wvalid.out & WREADY) & !w_handshake_occurred.out) ? 1'd1;
      wvalid.in = ((wvalid.out & WREADY) | w_handshake_occurred.out) ? 1'd0;
      wvalid.write_en = 1'd1;
      w_handshake_occurred.in = (wvalid.out & WREADY) ? 1'd1;
      w_handshake_occurred.in = !(wvalid.out & WREADY) ? 1'd0;
      w_handshake_occurred.write_en = !w_handshake_occurred.out ? 1'd1;
      WDATA = write_data;
      WLAST = 1'd1;
      bt_reg.in = (wvalid.out & WREADY) ? 1'd1;
      bt_reg.in = !(wvalid.out & WREADY) ? 1'd0;
      bt_reg.write_en = 1'd1;
      service_write_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{25} seq {
      @pos{23} invoke bt_reg(in=1'd0)();
      @pos{24} invoke w_handshake_occurred(in=1'd0)();
      @pos{25} service_write_transfer;
    }
  }
}
component m_bresp_channel_Sum0<"pos"={26}>(ARESETn: 1, BVALID: 1) -> (BREADY: 1) {
  cells {
    @pos{27} bready = std_reg(1);
    @pos{28} bt_reg = std_reg(1);
  }
  wires {
    BREADY = bready.out;
    group block_transfer<"pos"={29}> {
      bready.in = !(bready.out & BVALID) ? 1'd1;
      bready.in = (bready.out & BVALID) ? 1'd0;
      bready.write_en = 1'd1;
      bt_reg.in = (bready.out & BVALID) ? 1'd1;
      bt_reg.in = !(bready.out & BVALID) ? 1'd0;
      bt_reg.write_en = 1'd1;
      block_transfer[done] = bt_reg.out;
    }
  }
  control {
    @pos{30} seq {
      @pos{30} invoke bt_reg(in=1'd0)();
      @pos{30} block_transfer;
    }
  }
}
comb component address_translator_Sum0(calyx_mem_addr: 3) -> (axi_address: 64) {
  cells {
    @pos{31} mul_Sum0 = std_const_mult(64, 4);
    @pos{32} pad_input_addr = std_pad(3, 64);
  }
  wires {
    pad_input_addr.in = calyx_mem_addr;
    mul_Sum0.in = pad_input_addr.out;
    axi_address = mul_Sum0.out;
  }
}
component read_controller_Sum0<"pos"={33}>(axi_address: 64, ARESETn: 1, ARREADY: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2) -> (ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3, RREADY: 1, read_data: 32) {
  cells {
    @pos{34} ar_channel_Sum0 = m_ar_channel_Sum0();
    @pos{35} read_channel_Sum0 = m_read_channel_Sum0();
  }
  wires {
    read_data = read_channel_Sum0.read_data;
  }
  control {
    @pos{38} seq {
      @pos{36} invoke ar_channel_Sum0(axi_address=axi_address, ARESETn=ARESETn, ARREADY=ARREADY)(ARVALID=ARVALID, ARADDR=ARADDR, ARSIZE=ARSIZE, ARLEN=ARLEN, ARBURST=ARBURST, ARPROT=ARPROT);
      @pos{37} invoke read_channel_Sum0(ARESETn=ARESETn, RVALID=RVALID, RLAST=RLAST, RDATA=RDATA, RRESP=RRESP)(RREADY=RREADY);
    }
  }
}
component write_controller_Sum0<"pos"={39}>(axi_address: 64, write_data: 32, ARESETn: 1, AWREADY: 1, WREADY: 1, BVALID: 1) -> (AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3, WVALID: 1, WLAST: 1, WDATA: 32, BREADY: 1) {
  cells {
    @pos{40} aw_channel_Sum0 = m_aw_channel_Sum0();
    @pos{41} write_channel_Sum0 = m_write_channel_Sum0();
    @pos{42} bresp_channel_Sum0 = m_bresp_channel_Sum0();
  }
  wires {

  }
  control {
    @pos{46} seq {
      @pos{43} invoke aw_channel_Sum0(axi_address=axi_address, ARESETn=ARESETn, AWREADY=AWREADY)(AWVALID=AWVALID, AWADDR=AWADDR, AWSIZE=AWSIZE, AWLEN=AWLEN, AWBURST=AWBURST, AWPROT=AWPROT);
      @pos{44} invoke write_channel_Sum0(write_data=write_data, ARESETn=ARESETn, WREADY=WREADY)(WVALID=WVALID, WLAST=WLAST, WDATA=WDATA);
      @pos{45} invoke bresp_channel_Sum0(BVALID=BVALID)(BREADY=BREADY);
    }
  }
}
component axi_dyn_mem_Sum0<"pos"={47}>(@data @write_together(1) addr0: 3, @go(1) @write_together(1) content_en: 1, @write_together(2) write_en: 1, @data @write_together(2) write_data: 32, ARESETn: 1, ARREADY: 1, RVALID: 1, RLAST: 1, RDATA: 32, RRESP: 2, AWREADY: 1, WREADY: 1, BVALID: 1, BRESP: 2) -> (@stable read_data: 32, ARVALID: 1, ARADDR: 64, ARSIZE: 3, ARLEN: 8, ARBURST: 2, ARPROT: 3, RREADY: 1, AWVALID: 1, AWADDR: 64, AWSIZE: 3, AWLEN: 8, AWBURST: 2, AWPROT: 3, WVALID: 1, WLAST: 1, WDATA: 32, BREADY: 1) {
  cells {
    @pos{48} address_translator_Sum0 = address_translator_Sum0();
    @pos{49} read_controller_Sum0 = read_controller_Sum0();
    @pos{50} write_controller_Sum0 = write_controller_Sum0();
  }
  wires {
    address_translator_Sum0.calyx_mem_addr = addr0;
    read_data = read_controller_Sum0.read_data;
  }
  control {
    @pos{54} seq {
      @pos{53} if write_en {
        @pos{52} invoke write_controller_Sum0(axi_address=address_translator_Sum0.axi_address, write_data=write_data, ARESETn=ARESETn, AWREADY=AWREADY, WREADY=WREADY, BVALID=BVALID)(AWVALID=AWVALID, AWADDR=AWADDR, AWSIZE=AWSIZE, AWLEN=AWLEN, AWBURST=AWBURST, AWPROT=AWPROT, WVALID=WVALID, WLAST=WLAST, WDATA=WDATA, BREADY=BREADY);
      } else {
        @pos{51} invoke read_controller_Sum0(axi_address=address_translator_Sum0.axi_address, ARESETn=ARESETn, ARREADY=ARREADY, RVALID=RVALID, RLAST=RLAST, RDATA=RDATA, RRESP=RRESP)(ARVALID=ARVALID, ARADDR=ARADDR, ARSIZE=ARSIZE, ARLEN=ARLEN, ARBURST=ARBURST, ARPROT=ARPROT, RREADY=RREADY, read_data=read_data);
      }
    }
  }
}
component wrapper<"pos"={55}, "toplevel"=1>(@clk ap_clk: 1, A0_ARESETn: 1, A0_ARREADY: 1, A0_RVALID: 1, A0_RLAST: 1, A0_RDATA: 32, A0_RRESP: 2, A0_AWREADY: 1, A0_WREADY: 1, A0_BVALID: 1, A0_BRESP: 2, A0_RID: 1, B0_ARESETn: 1, B0_ARREADY: 1, B0_RVALID: 1, B0_RLAST: 1, B0_RDATA: 32, B0_RRESP: 2, B0_AWREADY: 1, B0_WREADY: 1, B0_BVALID: 1, B0_BRESP: 2, B0_RID: 1, Sum0_ARESETn: 1, Sum0_ARREADY: 1, Sum0_RVALID: 1, Sum0_RLAST: 1, Sum0_RDATA: 32, Sum0_RRESP: 2, Sum0_AWREADY: 1, Sum0_WREADY: 1, Sum0_BVALID: 1, Sum0_BRESP: 2, Sum0_RID: 1) -> (A0_ARVALID: 1, A0_ARADDR: 64, A0_ARSIZE: 3, A0_ARLEN: 8, A0_ARBURST: 2, A0_RREADY: 1, A0_AWVALID: 1, A0_AWADDR: 64, A0_AWSIZE: 3, A0_AWLEN: 8, A0_AWBURST: 2, A0_AWPROT: 3, A0_WVALID: 1, A0_WLAST: 1, A0_WDATA: 32, A0_BREADY: 1, A0_ARID: 1, A0_AWID: 1, A0_WID: 1, A0_BID: 1, B0_ARVALID: 1, B0_ARADDR: 64, B0_ARSIZE: 3, B0_ARLEN: 8, B0_ARBURST: 2, B0_RREADY: 1, B0_AWVALID: 1, B0_AWADDR: 64, B0_AWSIZE: 3, B0_AWLEN: 8, B0_AWBURST: 2, B0_AWPROT: 3, B0_WVALID: 1, B0_WLAST: 1, B0_WDATA: 32, B0_BREADY: 1, B0_ARID: 1, B0_AWID: 1, B0_WID: 1, B0_BID: 1, Sum0_ARVALID: 1, Sum0_ARADDR: 64, Sum0_ARSIZE: 3, Sum0_ARLEN: 8, Sum0_ARBURST: 2, Sum0_RREADY: 1, Sum0_AWVALID: 1, Sum0_AWADDR: 64, Sum0_AWSIZE: 3, Sum0_AWLEN: 8, Sum0_AWBURST: 2, Sum0_AWPROT: 3, Sum0_WVALID: 1, Sum0_WLAST: 1, Sum0_WDATA: 32, Sum0_BREADY: 1, Sum0_ARID: 1, Sum0_AWID: 1, Sum0_WID: 1, Sum0_BID: 1) {
  cells {
    @pos{56} main_compute = main();
    @pos{57} axi_dyn_mem_A0 = axi_dyn_mem_A0();
    @pos{57} axi_dyn_mem_B0 = axi_dyn_mem_B0();
    @pos{57} axi_dyn_mem_Sum0 = axi_dyn_mem_Sum0();
  }
  wires {
    A0_ARID = 1'd0;
    A0_AWID = 1'd0;
    A0_WID = 1'd0;
    A0_BID = 1'd0;
    axi_dyn_mem_A0.ARESETn = A0_ARESETn;
    axi_dyn_mem_A0.ARREADY = A0_ARREADY;
    axi_dyn_mem_A0.RVALID = A0_RVALID;
    axi_dyn_mem_A0.RLAST = A0_RLAST;
    axi_dyn_mem_A0.RDATA = A0_RDATA;
    axi_dyn_mem_A0.RRESP = A0_RRESP;
    A0_ARVALID = axi_dyn_mem_A0.ARVALID;
    A0_ARADDR = axi_dyn_mem_A0.ARADDR;
    A0_ARSIZE = axi_dyn_mem_A0.ARSIZE;
    A0_ARLEN = axi_dyn_mem_A0.ARLEN;
    A0_ARBURST = axi_dyn_mem_A0.ARBURST;
    A0_RREADY = axi_dyn_mem_A0.RREADY;
    axi_dyn_mem_A0.AWREADY = A0_AWREADY;
    axi_dyn_mem_A0.WREADY = A0_WREADY;
    axi_dyn_mem_A0.BVALID = A0_BVALID;
    A0_AWVALID = axi_dyn_mem_A0.AWVALID;
    A0_AWADDR = axi_dyn_mem_A0.AWADDR;
    A0_AWSIZE = axi_dyn_mem_A0.AWSIZE;
    A0_AWLEN = axi_dyn_mem_A0.AWLEN;
    A0_AWBURST = axi_dyn_mem_A0.AWBURST;
    A0_AWPROT = axi_dyn_mem_A0.AWPROT;
    A0_WVALID = axi_dyn_mem_A0.WVALID;
    A0_WLAST = axi_dyn_mem_A0.WLAST;
    A0_WDATA = axi_dyn_mem_A0.WDATA;
    A0_BREADY = axi_dyn_mem_A0.BREADY;
    B0_ARID = 1'd0;
    B0_AWID = 1'd0;
    B0_WID = 1'd0;
    B0_BID = 1'd0;
    axi_dyn_mem_B0.ARESETn = B0_ARESETn;
    axi_dyn_mem_B0.ARREADY = B0_ARREADY;
    axi_dyn_mem_B0.RVALID = B0_RVALID;
    axi_dyn_mem_B0.RLAST = B0_RLAST;
    axi_dyn_mem_B0.RDATA = B0_RDATA;
    axi_dyn_mem_B0.RRESP = B0_RRESP;
    B0_ARVALID = axi_dyn_mem_B0.ARVALID;
    B0_ARADDR = axi_dyn_mem_B0.ARADDR;
    B0_ARSIZE = axi_dyn_mem_B0.ARSIZE;
    B0_ARLEN = axi_dyn_mem_B0.ARLEN;
    B0_ARBURST = axi_dyn_mem_B0.ARBURST;
    B0_RREADY = axi_dyn_mem_B0.RREADY;
    axi_dyn_mem_B0.AWREADY = B0_AWREADY;
    axi_dyn_mem_B0.WREADY = B0_WREADY;
    axi_dyn_mem_B0.BVALID = B0_BVALID;
    B0_AWVALID = axi_dyn_mem_B0.AWVALID;
    B0_AWADDR = axi_dyn_mem_B0.AWADDR;
    B0_AWSIZE = axi_dyn_mem_B0.AWSIZE;
    B0_AWLEN = axi_dyn_mem_B0.AWLEN;
    B0_AWBURST = axi_dyn_mem_B0.AWBURST;
    B0_AWPROT = axi_dyn_mem_B0.AWPROT;
    B0_WVALID = axi_dyn_mem_B0.WVALID;
    B0_WLAST = axi_dyn_mem_B0.WLAST;
    B0_WDATA = axi_dyn_mem_B0.WDATA;
    B0_BREADY = axi_dyn_mem_B0.BREADY;
    Sum0_ARID = 1'd0;
    Sum0_AWID = 1'd0;
    Sum0_WID = 1'd0;
    Sum0_BID = 1'd0;
    axi_dyn_mem_Sum0.ARESETn = Sum0_ARESETn;
    axi_dyn_mem_Sum0.ARREADY = Sum0_ARREADY;
    axi_dyn_mem_Sum0.RVALID = Sum0_RVALID;
    axi_dyn_mem_Sum0.RLAST = Sum0_RLAST;
    axi_dyn_mem_Sum0.RDATA = Sum0_RDATA;
    axi_dyn_mem_Sum0.RRESP = Sum0_RRESP;
    Sum0_ARVALID = axi_dyn_mem_Sum0.ARVALID;
    Sum0_ARADDR = axi_dyn_mem_Sum0.ARADDR;
    Sum0_ARSIZE = axi_dyn_mem_Sum0.ARSIZE;
    Sum0_ARLEN = axi_dyn_mem_Sum0.ARLEN;
    Sum0_ARBURST = axi_dyn_mem_Sum0.ARBURST;
    Sum0_RREADY = axi_dyn_mem_Sum0.RREADY;
    axi_dyn_mem_Sum0.AWREADY = Sum0_AWREADY;
    axi_dyn_mem_Sum0.WREADY = Sum0_WREADY;
    axi_dyn_mem_Sum0.BVALID = Sum0_BVALID;
    Sum0_AWVALID = axi_dyn_mem_Sum0.AWVALID;
    Sum0_AWADDR = axi_dyn_mem_Sum0.AWADDR;
    Sum0_AWSIZE = axi_dyn_mem_Sum0.AWSIZE;
    Sum0_AWLEN = axi_dyn_mem_Sum0.AWLEN;
    Sum0_AWBURST = axi_dyn_mem_Sum0.AWBURST;
    Sum0_AWPROT = axi_dyn_mem_Sum0.AWPROT;
    Sum0_WVALID = axi_dyn_mem_Sum0.WVALID;
    Sum0_WLAST = axi_dyn_mem_Sum0.WLAST;
    Sum0_WDATA = axi_dyn_mem_Sum0.WDATA;
    Sum0_BREADY = axi_dyn_mem_Sum0.BREADY;
  }
  control {
    @pos{58} invoke main_compute[A0=axi_dyn_mem_A0, B0=axi_dyn_mem_B0, Sum0=axi_dyn_mem_Sum0]()();
  }
}

sourceinfo #{
FILES 
  0: dynamic_axi_generator.py
POSITIONS 
  0: 0 74
  1: 0 87
  2: 0 88
  3: 0 91
  4: 0 101
  5: 0 137
  6: 0 138
  7: 0 136
  8: 0 141
  9: 0 135
  10: 0 149
  11: 0 167
  12: 0 170
  13: 0 174
  14: 0 190
  15: 0 224
  16: 0 234
  17: 0 236
  18: 0 243
  19: 0 259
  20: 0 260
  21: 0 265
  22: 0 271
  23: 0 303
  24: 0 304
  25: 0 302
  26: 0 315
  27: 0 322
  28: 0 323
  29: 0 332
  30: 0 344
  31: 0 36
  32: 0 39
  33: 0 351
  34: 0 378
  35: 0 381
  36: 0 392
  37: 0 404
  38: 0 414
  39: 0 424
  40: 0 451
  41: 0 454
  42: 0 457
  43: 0 464
  44: 0 476
  45: 0 486
  46: 0 492
  47: 0 505
  48: 0 547
  49: 0 550
  50: 0 553
  51: 0 565
  52: 0 584
  53: 0 605
  54: 0 604
  55: 0 615
  56: 0 627
  57: 0 682
  58: 0 735
}#
