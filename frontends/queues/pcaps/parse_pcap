#!/usr/bin/env python3
# =========================================================================
# Usage: ./parse_pcap <PCAP> <JSON> [Option]...
# =========================================================================
# Arguments:
#  PCAP                Packet Capture to parse
#  JSON                JSON mapping MAC addresses to integer flows
#
# Options:
#  -h --help           Display this message
#
#  --num-packets  N    No. packets in PCAP to parse
#                      [default: 1000]
#
#  --clock-period C    Clock period of hardware in ns
#                      [default: 7]
#
#  --line-rate    L    Target line rate for pop frequency calculation in Gbit/s
#                      [default: 1]
#
#  --pop-tick     P    Time between consecutive pops in ns
#                      [default: calulated to achieve line rate]
#
# Example:
#  ./parse_pcap example.pcap addr2flow.json --num-packets 500

import sys
import random
import json
import dpkt
import argparse

CMD_PUSH = 1
CMD_POP = 0
DONTCARE = 0xFFFF_FFFF

CLOCK_PERIOD = 7  # in ns
NUM_PKTS = 500
POP_TICK = None  # in ns
LINE_RATE = 1  # in Gbit/s


def parse_pcap(pcap_file, addr2flow_json):
    global POP_TICK

    pcap = dpkt.pcap.Reader(pcap_file)
    addr2flow = json.load(addr2flow_json)

    offset = None
    total_size = 0
    for i, (ts, buf) in zip(range(NUM_PKTS), pcap):
        if i == 0:
            offset = ts
        total_size += len(buf)

    if POP_TICK is None:
        POP_TICK = int((total_size * 8) // (LINE_RATE * NUM_PKTS))

    def mac_addr(addr):
        return ":".join("%02x" % dpkt.compat.compat_ord(b) for b in addr)

    pcap_file.seek(0)
    pcap = dpkt.pcap.Reader(pcap_file)
    out = {"commands": [], "arrival_cycles": [], "flows": []}
    prev_time = 0
    for i, (ts, buf) in zip(range(NUM_PKTS), pcap):
        eth = dpkt.ethernet.Ethernet(buf)
        flow = addr2flow[mac_addr(eth.src)]
        time = (ts - offset) * 10**9  
        cycle = int(time // CLOCK_PERIOD)  

        num_pops = int((time - prev_time) // POP_TICK)
        out["commands"].extend([CMD_POP] * num_pops)
        out["arrival_cycles"].extend([DONTCARE] * num_pops)
        out["flows"].extend([DONTCARE] * num_pops)

        out["commands"].append(CMD_PUSH)
        out["arrival_cycles"].append(cycle)
        out["flows"].append(flow)

        prev_time = time
    return out


def gen_json(data):
    commands = data["commands"]
    arrival_cycles = data["arrival_cycles"]
    flows = data["flows"]
    values = [random.randint(0, 400) for _ in range(len(commands))]
    departure_cycles = [0] * len(commands)

    def format_gen(width):
        return {"is_signed": False, "numeric_type": "bitnum", "width": width}

    commands = {"commands": {"data": commands, "format": format_gen(1)}}
    arrival_cycles = {
        "arrival_cycles": {"data": arrival_cycles, "format": format_gen(32)}
    }
    flows = {"flows": {"data": flows, "format": format_gen(32)}}
    values = {"values": {"data": values, "format": format_gen(32)}}
    departure_cycles = {
        "departure_cycles": {"data": departure_cycles, "format": format_gen(32)}
    }

    return json.dumps(
        commands | arrival_cycles | flows | values | departure_cycles, indent=2
    )


class ArgumentParserWithCustomError(argparse.ArgumentParser):
    def __init__(self):
        super().__init__(add_help=False)

    def error(self, msg=None):
        if msg:
            print("ERROR: %s" % msg)
        file = open(sys.argv[0])
        for i, line in enumerate(file):
            if i == 0:
                continue
            elif line[0] == "#":
                print(line[1:].strip())
            else:
                sys.exit(1 if msg else 0)


def parse_cmdline():
    parser = ArgumentParserWithCustomError()

    parser.add_argument("-h", "--help", action="store_true")
    parser.add_argument("PCAP")
    parser.add_argument("JSON")

    def check_positive_int(x):
        try:
            x = int(x)
            if x <= 0:
                raise argparse.ArgumentTypeError(f"{x} is not a positive integer")
        except ValueError:
            raise argparse.ArgumentTypeError(f"{x} is not an integer")
        return x

    parser.add_argument(
        "--num-packets", type=check_positive_int, action="store", default=NUM_PKTS
    )
    parser.add_argument(
        "--clock-period", type=check_positive_int, action="store", default=CLOCK_PERIOD
    )
    parser.add_argument(
        "--pop-tick", type=check_positive_int, action="store", default=POP_TICK
    )

    def check_positive_float(x):
        try:
            x = float(x)
            if x <= 0:
                raise argparse.ArgumentTypeError(f"{x} is not a positive float")
        except ValueError:
            raise argparse.ArgumentTypeError(f"{x} is not a float")
        return x

    parser.add_argument(
        "--line-rate", type=check_positive_float, action="store", default=LINE_RATE
    )

    if "-h" in sys.argv or "--help" in sys.argv:
        parser.error()

    return parser.parse_args()


if __name__ == "__main__":
    opts = parse_cmdline()

    CLOCK_PERIOD = opts.clock_period
    NUM_PKTS = opts.num_packets
    POP_TICK = opts.pop_tick

    with open(opts.PCAP, "rb") as pcap_file:
        with open(opts.JSON) as addr2flow_json:
            data = parse_pcap(pcap_file, addr2flow_json)
            json = gen_json(data)
            print(json)
