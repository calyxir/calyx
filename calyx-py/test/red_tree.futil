import "primitives/core.futil";

component tree(leaf1: 32, leaf2: 32, leaf3: 32, leaf4: 32) -> (sum: 32) {
  // Creates a reduction tree with four leaves, and adds the leaves' inputs.
  //
  //            sum
  //           /   \
  //   left_node    right_node
  //   /       \   /         \
  // leaf1  leaf2  leaf3  leaf4

  cells {
    root = std_reg(32);
    left_node = std_reg(32);
    right_node = std_reg(32);

    add1 = std_add(32);
    add2 = std_add(32);
  }

  wires {
    group add_l1_l2 {
      // Adds leaf1 and leaf2, then puts the result in left_node.
      add1.left = leaf1;
      add1.right = leaf2;
      left_node.write_en = 1'b1;
      left_node.in = add1.out;
      add_l1_l2[done] = left_node.done;
    }
    group add_l3_l4 {
      // Adds leaf3 and leaf4, then puts the result in left_node.
      add2.left = leaf3;
      add2.right = leaf4;
      right_node.write_en = 1'b1;
      right_node.in = add2.out;
      add_l3_l4[done] = right_node.done;
    }
    group add_left_right_node {
      // Adds left_node and right_node, then puts the result in root.
      add1.left = left_node.out;
      add1.right = right_node.out;
      root.write_en = 1'b1;
      root.in = add1.out;
      add_left_right_node[done] = root.done;
    }
    // Continuous assignment of answer to `sum`.
    sum = root.out;
  }

  control {
    // Orchestrate the above straightforwardly.
    seq {
      par {
        add_l1_l2;
        add_l3_l4;
      }
      add_left_right_node;
    }
  }
}

component main() -> () {

  cells {
    // The four memories that will be driven by the `.data` file.
    @external A = std_mem_d1(32, 4, 32);
    @external B = std_mem_d1(32, 4, 32);
    @external C = std_mem_d1(32, 4, 32);
    @external D = std_mem_d1(32, 4, 32);

    // We will store the final answer here.
    // I'm using a memory of size 1 and not a reg because
    // IDK how to drive a register in the data file.
    @external ans = std_mem_d1(32, 1, 1);

    sum_col1 = std_reg(32);
    sum_col2 = std_reg(32);
    sum_col3 = std_reg(32);
    sum_col4 = std_reg(32);

    // Preparing to call the `tree` component.
    tree0 = tree();
    tree1 = tree();
    tree2 = tree();
    tree3 = tree();
    tree4 = tree();
  }

  wires {
    group tree0_col0 {
      A.addr0 = 32'd0;
      B.addr0 = 32'd0;
      C.addr0 = 32'd0;
      D.addr0 = 32'd0;
      tree0.leaf1 = A.read_data;
      tree0.leaf2 = B.read_data;
      tree0.leaf3 = C.read_data;
      tree0.leaf4 = D.read_data;
      tree0.go = 1'd1;
      tree0_col0[done] = tree0.done;
    }
    group tree1_col1 {
      A.addr0 = 32'd1;
      B.addr0 = 32'd1;
      C.addr0 = 32'd1;
      D.addr0 = 32'd1;
      tree1.leaf1 = A.read_data;
      tree1.leaf2 = B.read_data;
      tree1.leaf3 = C.read_data;
      tree1.leaf4 = D.read_data;
      tree1.go = 1'd1;
      tree1_col1[done] = tree1.done;
    }
    group tree2_col2 {
      A.addr0 = 32'd2;
      B.addr0 = 32'd2;
      C.addr0 = 32'd2;
      D.addr0 = 32'd2;
      tree2.leaf1 = A.read_data;
      tree2.leaf2 = B.read_data;
      tree2.leaf3 = C.read_data;
      tree2.leaf4 = D.read_data;
      tree2.go = 1'd1;
      tree2_col2[done] = tree2.done;
    }
    group tree3_col3 {
      A.addr0 = 32'd3;
      B.addr0 = 32'd3;
      C.addr0 = 32'd3;
      D.addr0 = 32'd3;
      tree3.leaf1 = A.read_data;
      tree3.leaf2 = B.read_data;
      tree3.leaf3 = C.read_data;
      tree3.leaf4 = D.read_data;
      tree3.go = 1'd1;
      tree3_col3[done] = tree3.done;
    }
    group tree4_total {
      tree4.leaf1 = tree0.sum;
      tree4.leaf2 = tree1.sum;
      tree4.leaf3 = tree2.sum;
      tree4.leaf4 = tree3.sum;
      tree4.go = 1'd1;
      tree4_total[done] = tree4.done;
    }
    group load_to_ans_mem {
      ans.addr0 = 1'b0;
      ans.write_data = tree4.sum;
      ans.write_en = 1'b1;
      load_to_ans_mem[done] = ans.done;
    }
  }

  control {
    seq {
      tree0_col0;
      tree1_col1;
      tree2_col2;
      tree3_col3;
      tree4_total;
      load_to_ans_mem;
    }
  }
}
