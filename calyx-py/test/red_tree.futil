import "primitives/core.futil";

component tree(leaf1: 32, leaf2: 32, leaf3: 32, leaf4: 32) -> (sum: 32) {
  // Creates a reduction tree with four leaves, and adds the leaves' inputs.
  //
  //            sum
  //           /   \
  //   left_node    right_node
  //   /       \   /         \
  // leaf1  leaf2  leaf3  leaf4

  cells {
    root = std_reg(32);
    left_node = std_reg(32);
    right_node = std_reg(32);

    add1 = std_add(32);
    add2 = std_add(32);
  }

  wires {
    group add_l1_l2 {
      // Adds leaf1 and leaf2, then puts the result in left_node.
      add1.left = leaf1;
      add1.right = leaf2;
      left_node.write_en = 1'b1;
      left_node.in = add1.out;
      add_l1_l2[done] = left_node.done;
    }
    group add_l3_l4 {
      // Adds leaf3 and leaf4, then puts the result in left_node.
      add2.left = leaf3;
      add2.right = leaf4;
      right_node.write_en = 1'b1;
      right_node.in = add2.out;
      add_l3_l4[done] = right_node.done;
    }
    group add_left_right_nodes {
      // Adds left_node and right_node, then puts the result in root.
      add1.left = left_node.out;
      add1.right = right_node.out;
      root.write_en = 1'b1;
      root.in = add1.out;
      add_left_right_nodes[done] = root.done;
    }
    // Continuous assignment of answer to `sum`.
    sum = root.out;
  }

  control {
    // Orchestrate the above straightforwardly.
    seq {
      par {
        add_l1_l2;
        add_l3_l4;
      }
      add_left_right_nodes;
    }
  }
}

component main() -> () {

  cells {
    // The four memories that will be driven by the `.data` file.
    @external A = std_mem_d1(32, 4, 32);
    @external B = std_mem_d1(32, 4, 32);
    @external C = std_mem_d1(32, 4, 32);
    @external D = std_mem_d1(32, 4, 32);

    // We will store the final answer here.
    // I'm using a memory of size 1 and not a reg because
    // IDK how to drive a register in the data file.
    @external ans = std_mem_d1(32, 1, 1);

    // We will store the intermediate answers here.
    sum_col0 = std_reg(32);
    sum_col1 = std_reg(32);
    sum_col2 = std_reg(32);
    sum_col3 = std_reg(32);


    // Preparing to call the `tree` component.
    tree = tree();
  }

  wires {
    group add_col0 {
      A.addr0 = 32'd0;
      B.addr0 = 32'd0;
      C.addr0 = 32'd0;
      D.addr0 = 32'd0;
      tree.leaf1 = A.read_data;
      tree.leaf2 = B.read_data;
      tree.leaf3 = C.read_data;
      tree.leaf4 = D.read_data;
      tree.go = 1'd1;
      sum_col0.in = tree.done ? tree.sum;
      add_col0[done] = sum_col0.done;
    }
    group add_col1 {
      A.addr0 = 32'd1;
      B.addr0 = 32'd1;
      C.addr0 = 32'd1;
      D.addr0 = 32'd1;
      tree.leaf1 = A.read_data;
      tree.leaf2 = B.read_data;
      tree.leaf3 = C.read_data;
      tree.leaf4 = D.read_data;
      tree.go = 1'd1;
      sum_col1.in = tree.done ? tree.sum;
      add_col1[done] = sum_col1.done;
    }
    group add_col2 {
      A.addr0 = 32'd2;
      B.addr0 = 32'd2;
      C.addr0 = 32'd2;
      D.addr0 = 32'd2;
      tree.leaf1 = A.read_data;
      tree.leaf2 = B.read_data;
      tree.leaf3 = C.read_data;
      tree.leaf4 = D.read_data;
      tree.go = 1'd1;
      sum_col2.in = tree.done ? tree.sum;
      add_col2[done] = sum_col2.done;
    }
    group add_col3 {
      A.addr0 = 32'd3;
      B.addr0 = 32'd3;
      C.addr0 = 32'd3;
      D.addr0 = 32'd3;
      tree.leaf1 = A.read_data;
      tree.leaf2 = B.read_data;
      tree.leaf3 = C.read_data;
      tree.leaf4 = D.read_data;
      tree.go = 1'd1;
      sum_col3.in = tree.done ? tree.sum;
      add_col3[done] = sum_col3.done;
    }
    group add_intermediates {
      tree.leaf1 = tree.sum;
      tree.leaf2 = tree.sum;
      tree.leaf3 = tree.sum;
      tree.leaf4 = tree.sum;
      tree.go = 1'd1;
      ans.addr0 = tree.done ? 1'b0;
      ans.write_data = tree.done ? tree.sum;
      ans.write_en = tree.done? 1'b1;
      add_intermediates[done] = ans.done;
    }
  }

  control {
    seq {
      add_col0;
      add_col1;
      add_col2;
      add_col3;
      add_intermediates;
    }
  }
}

