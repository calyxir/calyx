import "primitives/core.futil";
import "primitives/memories/seq.futil";
import "primitives/binary_operators.futil";
component binheap(cmd: 1, rank: 32, value: 32) -> () {
  cells {
    below = below();
    ref ans = std_reg(32);
    ref err = std_reg(1);
    reg_1 = std_reg(32);
    cat_2 = std_cat(32, 32, 64);
    reg_1_incr_1_3 = std_add(32);
  }
  wires {
    cat_2.left = rank;
    cat_2.right = reg_1.out;
    group reg_1_incr_1_3_group {
      reg_1_incr_1_3.left = reg_1.out;
      reg_1_incr_1_3.right = 32'd1;
      reg_1.write_en = 1'd1;
      reg_1.in = reg_1_incr_1_3.out;
      reg_1_incr_1_3_group[done] = reg_1.done;
    }
  }
  control {
    seq {
      invoke below[ans=ans, err=err](value=value, rank=cat_2.out, cmd=cmd)();
      reg_1_incr_1_3_group;
    }
  }
}
component below(cmd: 1, rank: 64, value: 32) -> () {
  cells {
    swap = swap();
    tuplify = tuplify();
    untuplify = untuplify();
    mem = seq_mem_d1(96, 16, 4);
    ref ans = std_reg(32);
    ref err = std_reg(1);
    reg_1 = std_reg(4);
    eq_2 = std_eq(1);
    eq_3 = std_eq(1);
    eq_4 = std_eq(4);
    reg_5 = std_reg(1);
    reg_6 = std_reg(4);
    reg_7 = std_reg(64);
    reg_8 = std_reg(4);
    reg_9 = std_reg(64);
    reg_10 = std_reg(4);
    reg_11 = std_reg(64);
    reg_12 = std_reg(4);
    reg_13 = std_reg(64);
    sub_14 = std_sub(4);
    rsh_15 = std_rsh(4);
    add_16 = std_add(4);
    add_17 = std_add(4);
    lsh_18 = std_lsh(4);
    lt_19 = std_lt(64);
    lt_20 = std_lt(4);
    and_21 = std_and(1);
    le_22 = std_le(4);
    le_23 = std_le(4);
    le_24 = std_le(64);
    or_25 = std_or(1);
    or_26 = std_or(1);
    lt_27 = std_lt(4);
    lt_28 = std_lt(4);
    lt_29 = std_lt(64);
    lt_30 = std_lt(4);
    lt_31 = std_lt(4);
    lt_32 = std_lt(64);
    and_33 = std_and(1);
    and_34 = std_and(1);
    and_35 = std_and(1);
    and_36 = std_and(1);
    or_37 = std_or(1);
    reg_1_decr_1_38 = std_sub(4);
    reg_1_incr_1_39 = std_add(4);
  }
  wires {
    comb group eq_2_group {
      eq_2.left = cmd;
      eq_2.right = 1'd0;
    }
    comb group eq_3_group {
      eq_3.left = cmd;
      eq_3.right = 1'd1;
    }
    comb group eq_4_group {
      eq_4.left = reg_1.out;
      eq_4.right = 4'd0;
    }
    group turn_full_on {
      reg_5.in = 1'd1;
      reg_5.write_en = 1'd1;
      turn_full_on[done] = reg_5.done;
    }
    group turn_full_off {
      reg_5.in = 1'd0;
      reg_5.write_en = 1'd1;
      turn_full_off[done] = reg_5.done;
    }
    group set_idx_zero {
      reg_6.in = 4'd0;
      reg_6.write_en = 1'd1;
      set_idx_zero[done] = reg_6.done;
    }
    group set_idx_size {
      reg_6.in = reg_1.out;
      reg_6.write_en = 1'd1;
      set_idx_size[done] = reg_6.done;
    }
    group set_idx_child_l {
      reg_6.in = reg_10.out;
      reg_6.write_en = 1'd1;
      set_idx_child_l[done] = reg_6.done;
    }
    group set_idx_child_r {
      reg_6.in = reg_12.out;
      reg_6.write_en = 1'd1;
      set_idx_child_r[done] = reg_6.done;
    }
    group set_idx_parent {
      reg_6.in = reg_8.out;
      reg_6.write_en = 1'd1;
      set_idx_parent[done] = reg_6.done;
    }
    group raise_err {
      err.in = 1'd1;
      err.write_en = 1'd1;
      raise_err[done] = err.done;
    }
    group lower_err {
      err.in = 1'd0;
      err.write_en = 1'd1;
      lower_err[done] = err.done;
    }
    group find_parent_idx {
      sub_14.left = reg_6.out;
      sub_14.right = 4'd1;
      rsh_15.left = sub_14.out;
      rsh_15.right = 4'd1;
      reg_8.in = rsh_15.out;
      reg_8.write_en = 1'd1;
      find_parent_idx[done] = reg_8.done;
    }
    group find_child_idx {
      lsh_18.left = reg_6.out;
      lsh_18.right = 4'd1;
      add_16.left = 4'd1;
      add_16.right = lsh_18.out;
      reg_10.write_en = 1'd1;
      reg_10.in = add_16.out;
      add_17.left = reg_10.done ? 4'd1;
      add_17.right = reg_10.done ? reg_10.out;
      reg_12.write_en = reg_10.done ? 1'd1;
      reg_12.in = reg_10.done ? add_17.out;
      find_child_idx[done] = reg_12.done;
    }
    group store_rank_and_value {
      tuplify.fst = rank;
      tuplify.snd = value;
      mem.addr0 = reg_6.out;
      mem.write_en = 1'd1;
      mem.content_en = 1'd1;
      mem.write_data = tuplify.tup;
      store_rank_and_value[done] = mem.done;
    }
    group extract_current_rank {
      mem.addr0 = reg_6.out;
      mem.content_en = 1'd1;
      untuplify.tup = mem.done ? mem.read_data;
      reg_7.write_en = mem.done ? 1'd1;
      reg_7.in = mem.done ? untuplify.fst;
      extract_current_rank[done] = reg_7.done;
    }
    group extract_parent_rank {
      mem.addr0 = reg_8.out;
      mem.content_en = 1'd1;
      untuplify.tup = mem.done ? mem.read_data;
      reg_9.write_en = mem.done ? 1'd1;
      reg_9.in = mem.done ? untuplify.fst;
      extract_parent_rank[done] = reg_9.done;
    }
    group extract_child_l_rank {
      mem.addr0 = reg_10.out;
      mem.content_en = 1'd1;
      untuplify.tup = mem.done ? mem.read_data;
      reg_11.write_en = mem.done ? 1'd1;
      reg_11.in = mem.done ? untuplify.fst;
      extract_child_l_rank[done] = reg_11.done;
    }
    group extract_child_r_rank {
      mem.addr0 = reg_12.out;
      mem.content_en = 1'd1;
      untuplify.tup = mem.done ? mem.read_data;
      reg_13.write_en = mem.done ? 1'd1;
      reg_13.in = mem.done ? untuplify.fst;
      extract_child_r_rank[done] = reg_13.done;
    }
    comb group current_lt_parent {
      lt_19.left = reg_7.out;
      lt_19.right = reg_9.out;
      lt_20.left = reg_8.out;
      lt_20.right = reg_6.out;
      and_21.left = lt_19.out;
      and_21.right = lt_20.out;
    }
    comb group child_l_swap {
      le_22.left = reg_1.out;
      le_22.right = reg_12.out;
      le_23.left = reg_12.out;
      le_23.right = reg_6.out;
      le_24.left = reg_11.out;
      le_24.right = reg_13.out;
      or_25.left = le_22.out;
      or_25.right = le_23.out;
      or_26.left = or_25.out;
      or_26.right = le_24.out;
    }
    comb group current_gt_children {
      lt_27.left = reg_10.out;
      lt_27.right = reg_1.out;
      lt_28.left = reg_6.out;
      lt_28.right = reg_10.out;
      lt_29.left = reg_11.out;
      lt_29.right = reg_7.out;
      lt_30.left = reg_12.out;
      lt_30.right = reg_1.out;
      lt_31.left = reg_6.out;
      lt_31.right = reg_12.out;
      lt_32.left = reg_13.out;
      lt_32.right = reg_7.out;
      and_33.left = lt_27.out;
      and_33.right = lt_28.out;
      and_34.left = and_33.out;
      and_34.right = lt_29.out;
      and_35.left = lt_30.out;
      and_35.right = lt_31.out;
      and_36.left = and_35.out;
      and_36.right = lt_32.out;
      or_37.left = and_34.out;
      or_37.right = and_36.out;
    }
    group peek {
      mem.addr0 = 4'd0;
      mem.content_en = 1'd1;
      untuplify.tup = mem.done ? mem.read_data;
      ans.write_en = mem.done ? 1'd1;
      ans.in = mem.done ? untuplify.snd;
      peek[done] = ans.done;
    }
    group reg_1_decr_1_38_group {
      reg_1_decr_1_38.left = reg_1.out;
      reg_1_decr_1_38.right = 4'd1;
      reg_1.write_en = 1'd1;
      reg_1.in = reg_1_decr_1_38.out;
      reg_1_decr_1_38_group[done] = reg_1.done;
    }
    group reg_1_incr_1_39_group {
      reg_1_incr_1_39.left = reg_1.out;
      reg_1_incr_1_39.right = 4'd1;
      reg_1.write_en = 1'd1;
      reg_1.in = reg_1_incr_1_39.out;
      reg_1_incr_1_39_group[done] = reg_1.done;
    }
  }
  control {
    seq {
      lower_err;
      par {
        if eq_2.out with eq_2_group {
          if reg_5.out {
            seq {
              seq {
                peek;
                reg_1_decr_1_38_group;
                set_idx_zero;
                invoke swap[mem=mem](a=reg_6.out, b=reg_1.out)();
                extract_current_rank;
                find_child_idx;
                extract_child_l_rank;
                extract_child_r_rank;
                while or_37.out with current_gt_children {
                  seq {
                    if or_26.out with child_l_swap {
                      seq {
                        invoke swap[mem=mem](a=reg_10.out, b=reg_6.out)();
                        set_idx_child_l;
                      }
                    } else {
                      seq {
                        invoke swap[mem=mem](a=reg_12.out, b=reg_6.out)();
                        set_idx_child_r;
                      }
                    }
                    find_child_idx;
                    extract_child_l_rank;
                    extract_child_r_rank;
                  }
                }
              }
              turn_full_off;
            }
          } else {
            if eq_4.out with eq_4_group {
              raise_err;
            } else {
              seq {
                peek;
                reg_1_decr_1_38_group;
                set_idx_zero;
                invoke swap[mem=mem](a=reg_6.out, b=reg_1.out)();
                extract_current_rank;
                find_child_idx;
                extract_child_l_rank;
                extract_child_r_rank;
                while or_37.out with current_gt_children {
                  seq {
                    if or_26.out with child_l_swap {
                      seq {
                        invoke swap[mem=mem](a=reg_10.out, b=reg_6.out)();
                        set_idx_child_l;
                      }
                    } else {
                      seq {
                        invoke swap[mem=mem](a=reg_12.out, b=reg_6.out)();
                        set_idx_child_r;
                      }
                    }
                    find_child_idx;
                    extract_child_l_rank;
                    extract_child_r_rank;
                  }
                }
              }
            }
          }
        }
        if eq_3.out with eq_3_group {
          seq {
            if reg_5.out {
              raise_err;
            } else {
              seq {
                set_idx_size;
                store_rank_and_value;
                reg_1_incr_1_39_group;
                find_parent_idx;
                extract_parent_rank;
                extract_current_rank;
                while and_21.out with current_lt_parent {
                  seq {
                    invoke swap[mem=mem](a=reg_8.out, b=reg_6.out)();
                    set_idx_parent;
                    find_parent_idx;
                    extract_parent_rank;
                  }
                }
              }
            }
            if eq_4.out with eq_4_group {
              turn_full_on;
            }
          }
        }
      }
    }
  }
}
component swap(a: 4, b: 4) -> () {
  cells {
    ref mem = seq_mem_d1(96, 16, 4);
    reg_1 = std_reg(96);
    reg_2 = std_reg(96);
  }
  wires {
    group load_a {
      mem.addr0 = a;
      mem.content_en = 1'd1;
      reg_1.write_en = mem.done ? 1'd1;
      reg_1.in = mem.done ? mem.read_data;
      load_a[done] = reg_1.done;
    }
    group load_b {
      mem.addr0 = b;
      mem.content_en = 1'd1;
      reg_2.write_en = mem.done ? 1'd1;
      reg_2.in = mem.done ? mem.read_data;
      load_b[done] = reg_2.done;
    }
    group store_a {
      mem.addr0 = a;
      mem.write_en = 1'd1;
      mem.write_data = reg_2.out;
      store_a[done] = mem.done;
      mem.content_en = 1'd1;
    }
    group store_b {
      mem.addr0 = b;
      mem.write_en = 1'd1;
      mem.write_data = reg_1.out;
      store_b[done] = mem.done;
      mem.content_en = 1'd1;
    }
  }
  control {
    seq {
      load_a;
      load_b;
      store_a;
      store_b;
    }
  }
}
comb component tuplify(fst: 64, snd: 32) -> (tup: 96) {
  cells {
    cat_1 = std_cat(64, 32, 96);
  }
  wires {
    cat_1.left = fst;
    cat_1.right = snd;
    tup = cat_1.out;
  }
}
comb component untuplify(tup: 96) -> (fst: 64, snd: 32) {
  cells {
    slice_out_fst = std_bit_slice(96, 32, 95, 64);
    slice_out_snd = std_slice(96, 32);
  }
  wires {
    slice_out_fst.in = tup;
    fst = slice_out_fst.out;
    slice_out_snd.in = tup;
    snd = slice_out_snd.out;
  }
}
component main() -> () {
  cells {
    dataplane = dataplane();
    reg_1 = std_reg(1);
    reg_2 = std_reg(32);
    reg_3 = std_reg(1);
    @external commands = seq_mem_d1(1, 20000, 32);
    @external values = seq_mem_d1(32, 20000, 32);
    @external ans_mem = seq_mem_d1(32, 20000, 32);
    @external ranks = seq_mem_d1(32, 20000, 32);
    reg_4 = std_reg(32);
    and_5 = std_and(1);
    lt_6 = std_lt(32);
    not_7 = std_not(1);
    reg_4_incr_1_8 = std_add(32);
  }
  wires {
    comb group Compute_keep_looping {
      lt_6.left = reg_4.out;
      lt_6.right = 32'd20000;
      not_7.in = reg_3.out;
      and_5.left = lt_6.out;
      and_5.right = not_7.out;
    }
    group lower_has_ans {
      reg_1.in = 1'd0;
      reg_1.write_en = 1'd1;
      lower_has_ans[done] = reg_1.done;
    }
    group lower_err {
      reg_3.in = 1'd0;
      reg_3.write_en = 1'd1;
      lower_err[done] = reg_3.done;
    }
    group write_ans {
      ans_mem.addr0 = reg_4.out;
      ans_mem.write_en = 1'd1;
      ans_mem.write_data = reg_2.out;
      write_ans[done] = ans_mem.done;
      ans_mem.content_en = 1'd1;
    }
    group write_err {
      ans_mem.addr0 = reg_4.out;
      ans_mem.write_en = 1'd1;
      ans_mem.write_data = 32'd20000;
      write_err[done] = ans_mem.done;
      ans_mem.content_en = 1'd1;
    }
    group write_push {
      ans_mem.addr0 = reg_4.out;
      ans_mem.write_en = 1'd1;
      ans_mem.write_data = 32'd10000;
      write_push[done] = ans_mem.done;
      ans_mem.content_en = 1'd1;
    }
    group reg_4_incr_1_8_group {
      reg_4_incr_1_8.left = reg_4.out;
      reg_4_incr_1_8.right = 32'd1;
      reg_4.write_en = 1'd1;
      reg_4.in = reg_4_incr_1_8.out;
      reg_4_incr_1_8_group[done] = reg_4.done;
    }
  }
  control {
    while and_5.out with Compute_keep_looping {
      seq {
        lower_has_ans;
        lower_err;
        invoke dataplane[commands=commands, values=values, ranks=ranks, has_ans=reg_1, component_ans=reg_2, component_err=reg_3]()();
        if reg_1.out {
          write_ans;
        } else {
          if reg_3.out {
            write_err;
          } else {
            write_push;
          }
        }

        reg_4_incr_1_8_group;
      }
    }
  }
}
component dataplane() -> () {
  cells {
    myqueue = binheap();
    ref commands = seq_mem_d1(1, 20000, 32);
    ref values = seq_mem_d1(32, 20000, 32);
    ref ranks = seq_mem_d1(32, 20000, 32);
    ref has_ans = std_reg(1);
    ref component_ans = std_reg(32);
    ref component_err = std_reg(1);
    reg_1 = std_reg(32);
    reg_2 = std_reg(1);
    reg_3 = std_reg(32);
    reg_4 = std_reg(32);
    not_5 = std_not(1);
    eq_6 = std_eq(1);
    reg_1_incr_1_7 = std_add(32);
  }
  wires {
    group write_cmd {
      commands.addr0 = reg_1.out;
      commands.content_en = 1'd1;
      reg_2.write_en = commands.done ? 1'd1;
      reg_2.in = commands.done ? commands.read_data;
      write_cmd[done] = reg_2.done;
    }
    group write_value {
      values.addr0 = reg_1.out;
      values.content_en = 1'd1;
      reg_3.write_en = values.done ? 1'd1;
      reg_3.in = values.done ? values.read_data;
      write_value[done] = reg_3.done;
    }
    group write_rank {
      ranks.addr0 = reg_1.out;
      ranks.content_en = 1'd1;
      reg_4.write_en = ranks.done ? 1'd1;
      reg_4.in = ranks.done ? ranks.read_data;
      write_rank[done] = reg_4.done;
    }
    comb group not_5_group {
      not_5.in = component_err.out;
    }
    group eq_6_group {
      eq_6.left = reg_2.out;
      eq_6.right = 1'd0;
      has_ans.write_en = 1'd1;
      has_ans.in = eq_6.out;
      eq_6_group[done] = has_ans.done;
    }
    group reg_1_incr_1_7_group {
      reg_1_incr_1_7.left = reg_1.out;
      reg_1_incr_1_7.right = 32'd1;
      reg_1.write_en = 1'd1;
      reg_1.in = reg_1_incr_1_7.out;
      reg_1_incr_1_7_group[done] = reg_1.done;
    }
  }
  control {
    seq {
      seq {
        write_cmd;
        write_value;
        write_rank;
      }
      invoke myqueue[ans=component_ans, err=component_err](cmd=reg_2.out, value=reg_3.out, rank=reg_4.out)();
      if not_5.out with not_5_group {
        seq {
          eq_6_group;
        }
      }
      reg_1_incr_1_7_group;
    }
  }
}
