import "primitives/core.futil";
import "primitives/memories/comb.futil";
import "primitives/binary_operators.futil";
import "primitives/unsynthesizable.futil";

// Modified from pass-in-register.futil
component multiply_and_add(
  // a: 32,
  // b: 32
) -> () {
  cells {
    ref acc = std_reg(32);
    ref loaded_val_a = std_reg(32);
    ref loaded_val_b = std_reg(32);
    add = std_add(32);
    mult = std_mult_pipe(32);
  }
  wires {
    group do_mul_and_add {
      mult.left = loaded_val_a.out;
      mult.right = loaded_val_b.out;
      mult.go = !mult.done ? 1'd1;

      add.left = acc.out;
      add.right = mult.out;

      acc.in = add.out;
      acc.write_en = 1'd1;
      do_mul_and_add[done] = acc.done;
    }
  }
  control {
    seq { do_mul_and_add; }
  }
}

component main() -> () {
  cells {
    // 4Ã—4 matrix memories
    @external arr_1 = comb_mem_d2(32, 4, 4, 4, 4);
    @external arr_2 = comb_mem_d2(32, 4, 4, 4, 4);
    @external mem_output = comb_mem_d2(32, 4, 4, 4, 4);

    // Constants
    const0 = std_const(32,3);
    const1 = std_const(32,0);
    const2 = std_const(32,1);

    // Registers
    i = std_reg(32);
    j = std_reg(32);
    k = std_reg(32);
    acc = std_reg(32);
    val_a = std_reg(32);
    val_b = std_reg(32);

    // Multiply-and-accumulate unit
    mul_add = multiply_and_add();

    // Comparators
    le0 = std_le(32);
    le1 = std_le(32);
    le2 = std_le(32);

    // Adder
    add = std_add(32);

    // Bit Slicer
    slice0 = std_slice(32, 4);
    slice1 = std_slice(32, 4);
  }

  wires {
    // Loop Conditions
    comb group cond0 { 
      le0.left = i.out; 
      le0.right = const0.out;
    }
    comb group cond1 { 
      le1.left = j.out; 
      le1.right = const0.out; 
    }
    comb group cond2 { 
      le2.left = k.out; 
      le2.right = const0.out; 
    }

    // Loop Initialization
    group let0<"promotable"=1> { 
      i.in = const1.out; 
      i.write_en = 1'd1; 
      let0[done] = i.done; 
    }
    group let1<"promotable"=1> { 
      j.in = const1.out; 
      j.write_en = 1'd1; 
      let1[done] = j.done; 
    }
    group let2<"promotable"=1> { 
      k.in = const1.out; 
      k.write_en = 1'd1; 
      let2[done] = k.done; 
    }

    // Accumulator Reset
    group begin_acc {
      acc.in = const1.out;
      acc.write_en = 1'd1;
      begin_acc[done] = acc.done;
    }

    group read_data {
      slice0.in = i.out;
      slice1.in = k.out;
      arr_1.addr0 = slice0.out; 
      arr_1.addr1 = slice1.out;
      arr_2.addr0 = slice1.out; 
      arr_2.addr1 = slice0.out;

      val_a.in = arr_1.read_data;
      val_a.write_en = 1'd1;
      val_b.in = arr_2.read_data;
      val_b.write_en = 1'd1;
      read_data[done] = val_b.done;
    }

    // group update_output {
      
    // }

    // Matrix Multiplication Update
    // group update_acc {
    //   // mul_add.reg_done = 1'd1;
    //   // mul_add.reg_out = acc.out;
    //   slice0.in = i.out;
    //   slice1.in = k.out;
    //   arr_1.addr0 = slice0.out; 
    //   arr_1.addr1 = slice1.out;
    //   arr_2.addr0 = slice1.out; 
    //   arr_2.addr1 = slice0.out;
    //   // mul_add.a = arr_1.read_data;
    //   // mul_add.b = arr_2.read_data;
    //   acc.in = mul_add.reg_in;
    //   acc.write_en = mul_add.reg_write_en;
    //   update_acc[done] = acc.done;
    // }

    // Writing results
    group write_result {
      slice0.in = i.out;
      slice1.in = j.out;
      mem_output.addr0 = slice0.out;
      mem_output.addr1 = slice1.out;
      mem_output.write_data = acc.out;
      mem_output.write_en = 1'd1;
      write_result[done] = mem_output.done;
    }

    // Loop Increment
    group updI<"promotable"=1> { 
      add.left = i.out; 
      add.right = const2.out; 
      i.in = add.out; 
      i.write_en = 1'd1; 
      updI[done] = i.done; 
    }
    group updJ<"promotable"=1> { 
      add.left = j.out; 
      add.right = const2.out; 
      j.in = add.out; 
      j.write_en = 1'd1; 
      updJ[done] = j.done; 
    }
    group updK<"promotable"=1> { 
      add.left = k.out; 
      add.right = const2.out; 
      k.in = add.out; 
      k.write_en = 1'd1; 
      updK[done] = k.done; 
    }
    group resetI {
      i.in = const1.out;
      i.write_en = 1'd1;
      resetI[done] = i.done;
    }
    group resetJ {
      j.in = const1.out;
      j.write_en = 1'd1;
      resetJ[done] = j.done;
    }
    group resetK {
      k.in = const1.out;
      k.write_en = 1'd1;
      resetK[done] = k.done;
    }
  }

  control {
    seq {
      // i, j, k initialization
      let0; 
      let1; 
      let2;
      resetI;
      while le0.out with cond0 {
        seq {
          resetJ;
          while le1.out with cond1 {
            seq {
              resetK;
              begin_acc; // Reset accumulator
              while le2.out with cond2 {
                seq { 
                  // update_acc; 
                  // group for reading data from the memories
                  read_data;
                  invoke mul_add[acc=acc, loaded_val_a=val_a, loaded_val_b=val_b]()();
                  // update output memory with computed value
                  updK; 
                }
              }
              write_result;
              updJ;
            }
          }
          updI;
        }
      }
    }
  }
}
