import "primitives/core.futil";
import "primitives/memories/comb.futil";
import "primitives/binary_operators.futil";
import "primitives/unsynthesizable.futil";

// Modified from pass-in-register.futil
component multiply_and_add(
  reg_done: 1,
  reg_out: 32,
  a: 32,
  b: 32
) -> (reg_in: 32, reg_write_en: 1) {
  cells {
    add = std_add(32);
    mult = std_unsyn_mult(32);
  }
  wires {
    group do_mul_and_add {
      mult.left = a;
      mult.right = b;

      add.left = reg_out;
      add.right = mult.out;

      reg_in = add.out;
      reg_write_en = 1'd1;
      do_mul_and_add[done] = reg_done;
    }
  }
  control {
    seq { do_mul_and_add; }
  }
}

component main() -> () {
  cells {
    // 4Ã—4 matrix memories
    @external arr_1 = comb_mem_d2(32, 4, 4, 4, 4);
    @external arr_2 = comb_mem_d2(32, 4, 4, 4, 4);
    mem_output = comb_mem_d2(32, 4, 4, 4, 4);

    // Constants
    const0 = std_const(32,3);
    const1 = std_const(32,0);
    const2 = std_const(32,1);

    // Registers
    i = std_reg(32);
    j = std_reg(32);
    k = std_reg(32);
    acc = std_reg(32);

    // Multiply-and-accumulate unit
    mul_add = multiply_and_add();

    // Comparators
    le0 = std_le(32);
    le1 = std_le(32);
    le2 = std_le(32);

    // Adder
    add = std_add(32);

    // Bit Slicer
    slice0 = std_slice(32, 4);
    slice1 = std_slice(32, 4);
  }

  wires {
    // Loop Conditions
    comb group cond0 { 
      le0.left = i.out; 
      le0.right = const0.out;
    }
    comb group cond1 { 
      le1.left = j.out; 
      le1.right = const0.out; 
    }
    comb group cond2 { 
      le2.left = k.out; 
      le2.right = const0.out; 
    }

    // Loop Initialization
    group let0<"promotable"=1> { 
      i.in = const1.out; 
      i.write_en = 1'd1; 
      let0[done] = i.done; 
    }
    group let1<"promotable"=1> { 
      j.in = const1.out; 
      j.write_en = 1'd1; 
      let1[done] = j.done; 
    }
    group let2<"promotable"=1> { 
      k.in = const1.out; 
      k.write_en = 1'd1; 
      let2[done] = k.done; 
    }

    // Accumulator Reset
    group begin_acc {
      acc.in = const1.out;
      acc.write_en = 1'd1;
      begin_acc[done] = acc.done;
    }

    // Matrix Multiplication Update
    group update_acc {
      mul_add.reg_done = 1'd1;
      mul_add.reg_out = acc.out;
      slice0.in = i.out;
      slice1.in = k.out;
      arr_1.addr0 = slice0.out; 
      arr_1.addr1 = slice1.out;
      arr_2.addr0 = slice1.out; 
      arr_2.addr1 = slice0.out;
      mul_add.a = arr_1.read_data;
      mul_add.b = arr_2.read_data;
      acc.in = mul_add.reg_in;
      acc.write_en = mul_add.reg_write_en;
      update_acc[done] = acc.done;
    }

    // Writing results
    group write_result {
      slice0.in = i.out;
      slice1.in = j.out;
      mem_output.addr0 = slice0.out;
      mem_output.addr1 = slice1.out;
      mem_output.write_data = acc.out;
      mem_output.write_en = 1'd1;
      write_result[done] = mem_output.done;
    }

    // Loop Increment
    group updI<"promotable"=1> { 
      add.left = i.out; 
      add.right = const2.out; 
      i.in = add.out; 
      i.write_en = 1'd1; 
      updI[done] = i.done; 
    }
    group updJ<"promotable"=1> { 
      add.left = j.out; 
      add.right = const2.out; 
      j.in = add.out; 
      j.write_en = 1'd1; 
      updJ[done] = j.done; 
    }
    group updK<"promotable"=1> { 
      add.left = k.out; 
      add.right = const2.out; 
      k.in = add.out; 
      k.write_en = 1'd1; 
      updK[done] = k.done; 
    }
    group resetI {
      i.in = const1.out;
      i.write_en = 1'd1;
      resetI[done] = i.done;
    }
    group resetJ {
      j.in = const1.out;
      j.write_en = 1'd1;
      resetJ[done] = j.done;
    }
    group resetK {
      k.in = const1.out;
      k.write_en = 1'd1;
      resetK[done] = k.done;
    }
  }

  control {
    seq {
      // i, j, k initialization
      let0; 
      let1; 
      let2;
      resetI;
      while le0.out with cond0 {
        seq {
          resetJ;
          while le1.out with cond1 {
            seq {
              resetK;
              begin_acc; // Reset accumulator
              while le2.out with cond2 {
                seq { 
                  update_acc; 
                  updK; 
                }
              }
              write_result;
              updJ;
            }
          }
          updI;
        }
      }
    }
  }
}
