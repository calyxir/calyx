use crate::exec::plan::FindPlan;
use crate::exec::plan::op_list_converter::prog_from_op_list;
use crate::exec::{OpRef, Operation, State, StateRef};
use crate::flang::Plan;
use cranelift_entity::{PrimaryMap, SecondaryMap};

use super::Request;

#[derive(Debug)]
pub struct InductivePlanner {}

const ALLOWED_OP_USES: u32 = 1;

impl FindPlan for InductivePlanner {
    fn find_plan(
        &self,
        req: &Request,
        ops: &PrimaryMap<OpRef, Operation>,
        states: &PrimaryMap<StateRef, State>,
    ) -> Option<Plan> {
        let mut state_count: SecondaryMap<StateRef, u32> = SecondaryMap::new();
        let mut op_use_count: SecondaryMap<OpRef, u32> = SecondaryMap::new();
        let mut state_use_count: SecondaryMap<StateRef, u32> =
            SecondaryMap::new();

        // Being an output state counts as being used
        for &s in req.end_states {
            state_use_count[s] += 1;
        }

        // Being an input means the state is available
        for &s in req.start_states {
            state_count[s] += 1;
        }

        let all_generated =
            |states: &[StateRef], env: &SecondaryMap<StateRef, u32>| {
                states.iter().all(|&s| env[s] > 0)
            };

        let mut outs_found = all_generated(req.end_states, &state_count);
        let mut num_ops = 0;
        'body: while !outs_found || num_ops == 0 {
            // iterate through throughs first
            for op in req.through.iter().copied().chain(ops.keys()) {
                if op_use_count[op] >= ALLOWED_OP_USES {
                    continue;
                }

                if all_generated(&ops[op].input, &state_count) {
                    op_use_count[op] += 1;
                    num_ops += 1;
                    for &s in &ops[op].input {
                        state_use_count[s] += 1;
                    }
                    for &s in &ops[op].output {
                        state_count[s] += 1;
                    }
                    outs_found = all_generated(req.end_states, &state_count);
                    continue 'body;
                }
            }

            // state_count has reached a fixed point but doesn't contain output states so return no plan found.
            return None;
        }

        // Prune ops
        loop {
            let mut pruned_op = false;
            for op_ref in req.through.iter().copied().chain(ops.keys()).rev() {
                if op_use_count[op_ref] == 0 {
                    continue;
                }

                // Remove op if it's outputs are all unused, or all generated by another op
                if ops[op_ref]
                    .output
                    .iter()
                    .all(|&s| state_use_count[s] == 0 || state_count[s] > 1)
                {
                    op_use_count[op_ref] -= 1;
                    for &s in &ops[op_ref].input {
                        state_use_count[s] -= 1;
                    }
                    for &s in &ops[op_ref].output {
                        state_count[s] -= 1;
                    }
                    pruned_op = true;
                }
            }

            if !pruned_op {
                break;
            }
        }

        // Make sure all of the ops required by through still exist.
        if !req.through.iter().all(|&op| op_use_count[op] > 0) {
            return None;
        }

        // Generate the op list and turn that into a plan.
        let mut op_list = vec![];
        for (op_ref, &uses) in op_use_count.iter() {
            if uses == 0 {
                continue;
            }
            let used_outputs: Vec<StateRef> = ops[op_ref]
                .output
                .iter()
                .copied()
                .filter(|&s| state_use_count[s] > 0)
                .collect();
            op_list.push((op_ref, used_outputs));
        }

        // fud2 rejects plans with no ops in them
        if op_list.len() == 0 {
            return None;
        }

        Some(prog_from_op_list(&op_list, req, ops, states))
    }
}
