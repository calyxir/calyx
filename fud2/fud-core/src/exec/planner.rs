use cranelift_entity::{PrimaryMap, SecondaryMap};

use super::{OpRef, Operation, StateRef};

/// `Step` is an op paired with its used outputs.
type Step = (OpRef, Vec<StateRef>);

/// A reified function for finding a sequence of operations taking a start set of states to an end
/// set of states while guaranteing a set of "though" operations is used in the sequence.
pub trait FindPlan: std::fmt::Debug {
    /// Returns a sequence of `Step`s to transform `start` to `end`. The `Step`s are guaranteed to
    /// contain all ops in `through`. If no such sequence exists, `None` is returned.
    ///
    /// `ops` is a complete list of operations.
    fn find_plan(
        &self,
        start: &[StateRef],
        end: &[StateRef],
        through: &[OpRef],
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>>;
}

#[derive(Debug, Default)]
pub struct EnumeratePlanner {}
impl EnumeratePlanner {
    /// The max number of ops in a searched for plan.
    const MAX_PLAN_LEN: u32 = 7;

    pub fn new() -> Self {
        EnumeratePlanner {}
    }

    /// Returns `true` if executing `plan` will take, `start` to `end` going through all ops in
    /// `through`.
    ///
    /// This function assumes all required inputs to `plan` exist or will be generated by `plan`.
    fn valid_plan(plan: &[Step], end: &[StateRef], through: &[OpRef]) -> bool {
        // Check all states in `end` are created.
        let end_created = end
            .iter()
            .all(|s| plan.iter().any(|(_, states)| states.contains(s)));

        // FIXME: Currently this checks that an outputs of an op specified by though is used.
        // However, it's possible that the only use of this output by another op whose outputs
        // are all unused. This means the plan doesn't actually use the specified op. but this
        // code reports it would.
        let through_used = through.iter().all(|t| {
            plan.iter()
                .any(|(op, used_states)| op == t && !used_states.is_empty())
        });

        end_created && through_used
    }

    /// A recursive function to generate all sequences prefixed by `plan` and containing `len` more
    /// `Steps`. Returns a sequence such that applying `good` to the sequence results in `true. If
    /// no such sequence exists, then `None` is returned.
    ///
    /// `start` is the base inputs which can be used for ops.
    /// `end` is the states to be generated by the return sequence of ops.
    /// `ops` contains all usable operations to construct `Step`s from.
    fn try_paths_of_length(
        plan: &mut Vec<Step>,
        len: u32,
        start: &[StateRef],
        end: &[StateRef],
        through: &[OpRef],
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>> {
        // Base case of the recursion. As `len == 0`, the algorithm reduces to applying `good` to
        // `plan.
        if len == 0 {
            return if Self::valid_plan(plan, end, through) {
                Some(plan.clone())
            } else {
                None
            };
        }

        // Try adding every op to the back of the current `plan`. Then recurse on the subproblem.
        for op_ref in ops.keys() {
            // Check previous ops in the plan to see if any generated an input to `op_ref`.
            let all_generated = ops[op_ref].input.iter().all(|input| {
                // Check the outputs of ops earlier in the plan can be used as inputs to `op_ref`.
                // `plan` is reversed so the latest versions of states are used.
                plan.iter_mut().rev().any(|(o, used_outputs)| {
                    // `op_ref`'s op now uses the input of the previous op in the plan.
                    // This should be noted in `used_outputs`.
                    if !used_outputs.contains(input)
                        && ops[*o].output.contains(input)
                    {
                        used_outputs.push(*input);
                    }

                    ops[*o].output.contains(input)
                })
                // As well as being generated in `plan`, `input` could be given in `start`.
                || start.contains(input)
            });

            // If this op cannot be uesd in the `plan` try a different one.
            if !all_generated {
                continue;
            }

            // Mark all outputs in `end` as used because they are used after being generated, just
            // maybe not by other ops in `plan`.
            let outputs = ops[op_ref].output.clone().into_iter();
            let used_outputs =
                outputs.filter(|s| end.contains(s)).collect::<Vec<_>>();

            // Recurse! Now that `len` has been reduced by one, see if this new problem has a
            // solution.
            plan.push((op_ref, used_outputs));
            if let Some(plan) = Self::try_paths_of_length(
                plan,
                len - 1,
                start,
                end,
                through,
                ops,
            ) {
                return Some(plan);
            }
            plan.pop();
        }

        // No sequence of `Step`s found :(.
        None
    }

    /// Returns a sequence of `Step`s to transform `start` to `end`. The `Step`s are guaranteed to
    /// contain all ops in `through`. If no such sequence exists, `None` is returned.
    ///
    /// `ops` is a complete list of operations.
    fn find_plan(
        start: &[StateRef],
        end: &[StateRef],
        through: &[OpRef],
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>> {
        // Try all sequences of ops up to `MAX_PATH_LEN`. At that point, the computation starts to
        // become really big.
        for len in 1..Self::MAX_PLAN_LEN {
            if let Some(plan) = Self::try_paths_of_length(
                &mut vec![],
                len,
                start,
                end,
                through,
                ops,
            ) {
                return Some(plan);
            }
        }

        // No sequence of `Step`s found :(.
        None
    }
}

impl FindPlan for EnumeratePlanner {
    fn find_plan(
        &self,
        start: &[StateRef],
        end: &[StateRef],
        through: &[OpRef],
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>> {
        Self::find_plan(start, end, through, ops)
    }
}

#[derive(PartialEq)]
enum Destination {
    State(StateRef),
    Op(OpRef),
}

#[derive(Debug, Default)]
pub struct SingleOpOutputPlanner {}
impl SingleOpOutputPlanner {
    /// Find a chain of Operations from the `start` state to the `end`, which may be a state or the
    /// final operation in the chain.
    fn find_path_segment(
        start: StateRef,
        end: Destination,
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>> {
        // Our start state is the input.
        let mut visited = SecondaryMap::<StateRef, bool>::new();
        visited[start] = true;

        // Build the incoming edges for each vertex.
        let mut breadcrumbs = SecondaryMap::<StateRef, Option<OpRef>>::new();

        // Breadth-first search.
        let mut state_queue: Vec<StateRef> = vec![start];
        while !state_queue.is_empty() {
            let cur_state = state_queue.remove(0);

            // Finish when we reach the goal vertex.
            if end == Destination::State(cur_state) {
                break;
            }

            // Traverse any edge from the current state to an unvisited state.
            for (op_ref, op) in ops.iter() {
                if op.input[0] == cur_state && !visited[op.output[0]] {
                    state_queue.push(op.output[0]);
                    visited[op.output[0]] = true;
                    breadcrumbs[op.output[0]] = Some(op_ref);
                }

                // Finish when we reach the goal edge.
                if end == Destination::Op(op_ref) {
                    break;
                }
            }
        }

        // Traverse the breadcrumbs backward to build up the path back from output to input.
        let mut op_path: Vec<OpRef> = vec![];
        let mut cur_state = match end {
            Destination::State(state) => state,
            Destination::Op(op) => {
                op_path.push(op);
                ops[op].input[0]
            }
        };
        while cur_state != start {
            match breadcrumbs[cur_state] {
                Some(op) => {
                    op_path.push(op);
                    cur_state = ops[op].input[0];
                }
                None => return None,
            }
        }
        op_path.reverse();

        Some(
            op_path
                .iter()
                .map(|&op| (op, vec![ops[op].output[0]]))
                .collect::<Vec<_>>(),
        )
    }

    /// Find a chain of operations from the `start` state to the `end` state, passing through each
    /// `through` operation in order.
    pub fn find_plan(
        start: StateRef,
        end: StateRef,
        through: &[OpRef],
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>> {
        let mut cur_state = start;
        let mut op_path = vec![];

        // Build path segments through each through required operation.
        for op in through {
            let segment =
                Self::find_path_segment(cur_state, Destination::Op(*op), ops)?;
            op_path.extend(segment);
            cur_state = ops[*op].output[0];
        }

        // Build the final path segment to the destination state.
        let segment =
            Self::find_path_segment(cur_state, Destination::State(end), ops)?;
        op_path.extend(segment);

        Some(op_path)
    }
}

impl FindPlan for SingleOpOutputPlanner {
    fn find_plan(
        &self,
        start: &[StateRef],
        end: &[StateRef],
        through: &[OpRef],
        ops: &PrimaryMap<OpRef, Operation>,
    ) -> Option<Vec<Step>> {
        assert!(start.len() == 1 && end.len() == 1);
        Self::find_plan(start[0], end[0], through, ops)
    }
}
