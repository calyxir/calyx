decl alpha: ubit<32>[1];
decl beta: ubit<32>[1];
decl A: ubit<32>[8 bank 2][8 bank 2];
decl u1: ubit<32>[8 bank 2];
decl v1: ubit<32>[8 bank 2];
decl u2: ubit<32>[8 bank 2];
decl v2: ubit<32>[8 bank 2];
decl w: ubit<32>[8 bank 2];
decl x: ubit<32>[8 bank 2];
decl y: ubit<32>[8 bank 2];
decl z: ubit<32>[8 bank 2];

// Scalar inputs.
let alpha_ = alpha[0];
let beta_ = beta[0];

for (let i: ubit<4> = 0..8) unroll 2 {
  for (let j: ubit<4> = 0..8) unroll 2 {
    let tmp1 = u1[i] * v1[j] + u2[i] * v2[j];
    let old = A[i][j];
    ---
    A[i][j] := old + tmp1;
  }
}
---
for (let i: ubit<4> = 0..8) unroll 2 {
  for (let j: ubit<4> = 0..8) unroll 2 {
    let tmp2 = beta_ * A[j][i] * y[j];
  } combine {
    x[i] += tmp2;
  }
}
---
// We could've moved this up and parallelized with loop1.
for (let i: ubit<4> = 0..8) unroll 2 {
  let tmp3 = z[i];
  let old = x[i];
  ---
  x[i] := old + tmp3;
}
---
for (let i: ubit<4> = 0..8) unroll 2 {
  for (let j: ubit<4> = 0..8) unroll 2 {
    let tmp4 = alpha_ * A[i][j] * x[j];
  } combine {
    w[i] += tmp4;
  }
}
