use calyx_utils::{CalyxResult, Error, Id};

/// Attributes that have been deprecated.
pub const DEPRECATED_ATTRIBUTES: &[&str] = &[];

#[derive(Clone, Copy, Hash, PartialEq, Eq, Debug)]
#[allow(non_camel_case_types)]
/// Defines the known attributes that can be attached to IR nodes.
/// All caps names represent attributes that are internal to the compiler and
/// cannot be parsed back.
pub enum Attribute {
    // ============ 1-bit attributes ============
    /// This is the top-level component
    TopLevel,
    /// Cell should be externalized
    External,
    /// The component doesn't have a standard interface
    NoInterface,
    /// Reset signal for the component
    Reset,
    /// Clk for the signal
    Clk,
    /// Is the port connected to a state element
    Stable,
    /// This is a data path component
    Data,
    /// Is this component shareable
    Share,
    /// Is the component state shareable
    StateShare,
    /// Synchronize this thread with others in the current par block
    Sync,
    /// IR Node was generated by the compiler
    Generated,
    /// Generate a new FSM for this control node
    NewFSM,
    /// Inline this subcomponent
    Inline,
    /// This assignment is dead
    DEAD,

    // ============ numeric attributes ============
    // Interface ports
    Go,
    Done,
    // Interface properties
    ReadTogether,
    WriteTogether,
    /// The bound of a while loop
    Bound,
    /// Latency information
    Static,
    /// Source location position for this node
    Pos,

    // ============ Internal attributes ============
    // Internal attributes. Not for public use and the frontend cannot parse them.
    NODE_ID,
    BEGIN_ID,
    END_ID,
    ST_ID,
    LOOP,
    START,
    END,

    /// Unknown attribute. Should not appear in the Calyx codebase.
    /// Useful for other frontends using Calyx
    Unknown(Id),
}

impl Attribute {
    #[inline]
    /// Generates index for 1-bit attributes
    const fn inline_idx(&self) -> Option<u16> {
        match self {
            Attribute::TopLevel => Some(0),
            Attribute::External => Some(1),
            Attribute::NoInterface => Some(2),
            Attribute::Reset => Some(3),
            Attribute::Clk => Some(4),
            Attribute::Stable => Some(5),
            Attribute::Data => Some(6),
            Attribute::Share => Some(7),
            Attribute::StateShare => Some(8),
            Attribute::Sync => Some(9),
            Attribute::Generated => Some(10),
            Attribute::NewFSM => Some(11),
            Attribute::Inline => Some(12),
            Attribute::DEAD => Some(13),
            _ => None,
        }
    }

    /// Check if the attribute is inlinable
    pub const fn is_inline(&self) -> bool {
        matches!(
            self,
            Attribute::TopLevel
                | Attribute::External
                | Attribute::NoInterface
                | Attribute::Reset
                | Attribute::Clk
                | Attribute::Stable
                | Attribute::Data
                | Attribute::Share
                | Attribute::StateShare
                | Attribute::Sync
                | Attribute::Generated
                | Attribute::NewFSM
                | Attribute::Inline
                | Attribute::DEAD
        )
    }
}

#[derive(Default, Debug, Clone)]
/// Inline storage for attributes that are guaranteed to be 1-bit
pub(super) struct InlineAttributes {
    /// 1-bit attributes are stored in a single u16
    attrs: u16,
}

impl InlineAttributes {
    /// Is the attribute set empty?
    pub const fn is_empty(&self) -> bool {
        self.attrs == 0
    }

    /// Adds an attribute to the set
    pub fn insert(&mut self, attr: Attribute) {
        if let Some(idx) = attr.inline_idx() {
            self.attrs |= 1 << idx;
        } else {
            unreachable!("Cannot add non-inline attribute to inline set")
        }
    }

    /// Checks if the set contains an attribute
    pub fn has(&self, attr: Attribute) -> bool {
        if let Some(idx) = attr.inline_idx() {
            self.attrs & (1 << idx) != 0
        } else {
            unreachable!("Cannot check for non-inline attribute in inline set")
        }
    }

    /// Remove attribute from the set if present
    pub fn remove(&mut self, attr: Attribute) {
        if let Some(idx) = attr.inline_idx() {
            self.attrs &= !(1 << idx);
        } else {
            unreachable!("Cannot remove non-inline attribute from inline set")
        }
    }
}

impl From<Attribute> for Id {
    fn from(attr: Attribute) -> Id {
        match attr {
            Attribute::TopLevel => "toplevel".into(),
            Attribute::NoInterface => "nointerface".into(),
            Attribute::Go => "go".into(),
            Attribute::Done => "done".into(),
            Attribute::Reset => "reset".into(),
            Attribute::Clk => "clk".into(),
            Attribute::Static => "static".into(),
            Attribute::Stable => "stable".into(),
            Attribute::Sync => "sync".into(),
            Attribute::ReadTogether => "read_together".into(),
            Attribute::WriteTogether => "write_together".into(),
            Attribute::StateShare => "state_share".into(),
            Attribute::Share => "share".into(),
            Attribute::Data => "data".into(),
            Attribute::Generated => "generated".into(),
            Attribute::Bound => "bound".into(),
            Attribute::Pos => "pos".into(),
            // Internal attributes
            Attribute::DEAD => "DEAD".into(),
            Attribute::NODE_ID => "NODE_ID".into(),
            Attribute::BEGIN_ID => "BEGIN_ID".into(),
            Attribute::END_ID => "END_ID".into(),
            Attribute::External => "external".into(),
            Attribute::NewFSM => "new_fsm".into(),
            Attribute::Inline => "inline".into(),
            Attribute::ST_ID => "ST_ID".into(),
            Attribute::LOOP => "LOOP".into(),
            Attribute::START => "START".into(),
            Attribute::END => "END".into(),
            // Unknown attribute
            Attribute::Unknown(s) => s,
        }
    }
}

impl ToString for Attribute {
    fn to_string(&self) -> String {
        Id::from(*self).to_string()
    }
}

impl TryFrom<String> for Attribute {
    type Error = Error;

    fn try_from(s: String) -> CalyxResult<Self> {
        if DEPRECATED_ATTRIBUTES.contains(&s.as_str()) {
            return Err(Error::malformed_structure(format!(
                "Attribute {s} is deprecated"
            )));
        }

        Ok(match s.as_str() {
            "toplevel" => Attribute::TopLevel,
            "external" => Attribute::External,
            "nointerface" => Attribute::NoInterface,
            "generated" => Attribute::Generated,
            "go" => Attribute::Go,
            "done" => Attribute::Done,
            "reset" => Attribute::Reset,
            "clk" => Attribute::Clk,
            "sync" => Attribute::Sync,
            "static" => Attribute::Static,
            "bound" => Attribute::Bound,
            "stable" => Attribute::Stable,
            "read_together" => Attribute::ReadTogether,
            "write_together" => Attribute::WriteTogether,
            "state_share" => Attribute::StateShare,
            "share" => Attribute::Share,
            "data" => Attribute::Data,
            "new_fsm" => Attribute::NewFSM,
            "inline" => Attribute::Inline,
            "pos" => Attribute::Pos,
            _ => Attribute::Unknown(s.into()),
        })
    }
}
