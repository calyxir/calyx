def conv2d_1x64x111x111(data: fix<32, 16>[1][3][224][224], squeezenet0_conv0_weight: fix<32, 16>[64][3][3][3], x: fix<32, 16>[1][64][111][111]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..111) {
                for (let __x: ubit<32> = 0..111) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..3) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/2 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/2 * __x) + __dx;
                      } combine {
                        __sum += data[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv0_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x111x111(x: fix<32, 16>[1][64][111][111], squeezenet0_conv0_bias: fix<32, 16>[64], x1: fix<32, 16>[1][64][111][111]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<7> = 0..111) {
        for (let __l: ubit<7> = 0..111) {
          x1[__i][__j][__k][__l] :=
                          x[__i][__j][__k][__l] + squeezenet0_conv0_bias[__j];
        }
      }
    }
  }
}def relu_1x64x111x111(x1: fix<32, 16>[1][64][111][111], x2: fix<32, 16>[1][64][111][111]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<7> = 0..111) {
        for (let __l: ubit<7> = 0..111) {
          if (x1[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x2[__i][__j][__k][__l] := x1[__i][__j][__k][__l]; }
                              else { x2[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def max_pool2d_1x64x55x55(x2: fix<32, 16>[1][64][111][111], x3: fix<32, 16>[1][64][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __stride_y: ubit<32> = __y * 2/*strides[0]*/;
                  let __stride_x: ubit<32> = __x * 2/*strides[1]*/;

                  let __max: fix<32, 16> = x2[__b][__c][__stride_y][__stride_x];
                  for (let __m: ubit<32> = 0..3/*pool_size[0]*/) {
                    for (let __n: ubit<32> = 0..3/*pool_size[1]*/) {
                      let __pool_y: ubit<32> = __stride_y + __m;
                      let __pool_x: ubit<32> = __stride_x + __n;
                      let __current: fix<32, 16> = x2[__b][__c][__pool_y][__pool_x];
                      if (__current > __max) { __max := __current; }
                    }
                  }
                  x3[__b][__c][__y][__x] := __max;
                }
              }
            }
          }
        
}def conv2d_1x16x55x55(x3: fix<32, 16>[1][64][55][55], squeezenet0_conv1_weight: fix<32, 16>[16][64][1][1], x4: fix<32, 16>[1][16][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..16) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..64) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x3[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv1_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x4[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x16x55x55(x4: fix<32, 16>[1][16][55][55], squeezenet0_conv1_bias: fix<32, 16>[16], x5: fix<32, 16>[1][16][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<5> = 0..16) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x5[__i][__j][__k][__l] :=
                          x4[__i][__j][__k][__l] + squeezenet0_conv1_bias[__j];
        }
      }
    }
  }
}def relu_1x16x55x55(x5: fix<32, 16>[1][16][55][55], x6: fix<32, 16>[1][16][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<5> = 0..16) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          if (x5[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x6[__i][__j][__k][__l] := x5[__i][__j][__k][__l]; }
                              else { x6[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x64x55x55(x6: fix<32, 16>[1][16][55][55], squeezenet0_conv2_weight: fix<32, 16>[64][16][1][1], x7: fix<32, 16>[1][64][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..16) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x6[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv2_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x7[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x55x55(x7: fix<32, 16>[1][64][55][55], squeezenet0_conv2_bias: fix<32, 16>[64], x8: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x8[__i][__j][__k][__l] :=
                          x7[__i][__j][__k][__l] + squeezenet0_conv2_bias[__j];
        }
      }
    }
  }
}def relu_1x64x55x55(x8: fix<32, 16>[1][64][55][55], x9: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          if (x8[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x9[__i][__j][__k][__l] := x8[__i][__j][__k][__l]; }
                              else { x9[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x64x55x55_1(x6: fix<32, 16>[1][16][55][55], squeezenet0_conv3_weight: fix<32, 16>[64][16][3][3], x10: fix<32, 16>[1][64][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..16) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x6[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv3_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x10[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x55x55_1(x10: fix<32, 16>[1][64][55][55], squeezenet0_conv3_bias: fix<32, 16>[64], x11: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x11[__i][__j][__k][__l] :=
                          x10[__i][__j][__k][__l] + squeezenet0_conv3_bias[__j];
        }
      }
    }
  }
}def relu_1x64x55x55_1(x11: fix<32, 16>[1][64][55][55], x12: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          if (x11[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x12[__i][__j][__k][__l] := x11[__i][__j][__k][__l]; }
                              else { x12[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x128x55x55(x9: fix<32, 16>[1][64][55][55], x12: fix<32, 16>[1][64][55][55], x14: fix<32, 16>[1][128][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x14[__i][__j][__k][__l] := x9[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x14[__i][__j + 64][__k][__l] := x12[__i][__j][__k][__l];
        }
      }
    }
  }
}def conv2d_1x16x55x55_1(x14: fix<32, 16>[1][128][55][55], squeezenet0_conv4_weight: fix<32, 16>[16][128][1][1], x15: fix<32, 16>[1][16][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..16) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..128) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x14[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv4_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x15[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x16x55x55_1(x15: fix<32, 16>[1][16][55][55], squeezenet0_conv4_bias: fix<32, 16>[16], x16: fix<32, 16>[1][16][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<5> = 0..16) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x16[__i][__j][__k][__l] :=
                          x15[__i][__j][__k][__l] + squeezenet0_conv4_bias[__j];
        }
      }
    }
  }
}def relu_1x16x55x55_1(x16: fix<32, 16>[1][16][55][55], x17: fix<32, 16>[1][16][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<5> = 0..16) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          if (x16[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x17[__i][__j][__k][__l] := x16[__i][__j][__k][__l]; }
                              else { x17[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x64x55x55_2(x17: fix<32, 16>[1][16][55][55], squeezenet0_conv5_weight: fix<32, 16>[64][16][1][1], x18: fix<32, 16>[1][64][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..16) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x17[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv5_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x18[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x55x55_2(x18: fix<32, 16>[1][64][55][55], squeezenet0_conv5_bias: fix<32, 16>[64], x19: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x19[__i][__j][__k][__l] :=
                          x18[__i][__j][__k][__l] + squeezenet0_conv5_bias[__j];
        }
      }
    }
  }
}def relu_1x64x55x55_2(x19: fix<32, 16>[1][64][55][55], x20: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          if (x19[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x20[__i][__j][__k][__l] := x19[__i][__j][__k][__l]; }
                              else { x20[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x64x55x55_3(x17: fix<32, 16>[1][16][55][55], squeezenet0_conv6_weight: fix<32, 16>[64][16][3][3], x21: fix<32, 16>[1][64][55][55]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..55) {
                for (let __x: ubit<32> = 0..55) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..16) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x17[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv6_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x21[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x55x55_3(x21: fix<32, 16>[1][64][55][55], squeezenet0_conv6_bias: fix<32, 16>[64], x22: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x22[__i][__j][__k][__l] :=
                          x21[__i][__j][__k][__l] + squeezenet0_conv6_bias[__j];
        }
      }
    }
  }
}def relu_1x64x55x55_3(x22: fix<32, 16>[1][64][55][55], x23: fix<32, 16>[1][64][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          if (x22[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x23[__i][__j][__k][__l] := x22[__i][__j][__k][__l]; }
                              else { x23[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x128x55x55_1(x20: fix<32, 16>[1][64][55][55], x23: fix<32, 16>[1][64][55][55], x25: fix<32, 16>[1][128][55][55]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x25[__i][__j][__k][__l] := x20[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<6> = 0..55) {
        for (let __l: ubit<6> = 0..55) {
          x25[__i][__j + 64][__k][__l] := x23[__i][__j][__k][__l];
        }
      }
    }
  }
}def max_pool2d_1x128x27x27(x25: fix<32, 16>[1][128][55][55], x26: fix<32, 16>[1][128][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..128) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __stride_y: ubit<32> = __y * 2/*strides[0]*/;
                  let __stride_x: ubit<32> = __x * 2/*strides[1]*/;

                  let __max: fix<32, 16> = x25[__b][__c][__stride_y][__stride_x];
                  for (let __m: ubit<32> = 0..3/*pool_size[0]*/) {
                    for (let __n: ubit<32> = 0..3/*pool_size[1]*/) {
                      let __pool_y: ubit<32> = __stride_y + __m;
                      let __pool_x: ubit<32> = __stride_x + __n;
                      let __current: fix<32, 16> = x25[__b][__c][__pool_y][__pool_x];
                      if (__current > __max) { __max := __current; }
                    }
                  }
                  x26[__b][__c][__y][__x] := __max;
                }
              }
            }
          }
        
}def conv2d_1x32x27x27(x26: fix<32, 16>[1][128][27][27], squeezenet0_conv7_weight: fix<32, 16>[32][128][1][1], x27: fix<32, 16>[1][32][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..32) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..128) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x26[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv7_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x27[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x32x27x27(x27: fix<32, 16>[1][32][27][27], squeezenet0_conv7_bias: fix<32, 16>[32], x28: fix<32, 16>[1][32][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..32) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x28[__i][__j][__k][__l] :=
                          x27[__i][__j][__k][__l] + squeezenet0_conv7_bias[__j];
        }
      }
    }
  }
}def relu_1x32x27x27(x28: fix<32, 16>[1][32][27][27], x29: fix<32, 16>[1][32][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..32) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          if (x28[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x29[__i][__j][__k][__l] := x28[__i][__j][__k][__l]; }
                              else { x29[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x128x27x27(x29: fix<32, 16>[1][32][27][27], squeezenet0_conv8_weight: fix<32, 16>[128][32][1][1], x30: fix<32, 16>[1][128][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..128) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..32) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x29[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv8_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x30[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x128x27x27(x30: fix<32, 16>[1][128][27][27], squeezenet0_conv8_bias: fix<32, 16>[128], x31: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x31[__i][__j][__k][__l] :=
                          x30[__i][__j][__k][__l] + squeezenet0_conv8_bias[__j];
        }
      }
    }
  }
}def relu_1x128x27x27(x31: fix<32, 16>[1][128][27][27], x32: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          if (x31[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x32[__i][__j][__k][__l] := x31[__i][__j][__k][__l]; }
                              else { x32[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x128x27x27_1(x29: fix<32, 16>[1][32][27][27], squeezenet0_conv9_weight: fix<32, 16>[128][32][3][3], x33: fix<32, 16>[1][128][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..128) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..32) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x29[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv9_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x33[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x128x27x27_1(x33: fix<32, 16>[1][128][27][27], squeezenet0_conv9_bias: fix<32, 16>[128], x34: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x34[__i][__j][__k][__l] :=
                          x33[__i][__j][__k][__l] + squeezenet0_conv9_bias[__j];
        }
      }
    }
  }
}def relu_1x128x27x27_1(x34: fix<32, 16>[1][128][27][27], x35: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          if (x34[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x35[__i][__j][__k][__l] := x34[__i][__j][__k][__l]; }
                              else { x35[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x256x27x27(x32: fix<32, 16>[1][128][27][27], x35: fix<32, 16>[1][128][27][27], x37: fix<32, 16>[1][256][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x37[__i][__j][__k][__l] := x32[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x37[__i][__j + 128][__k][__l] := x35[__i][__j][__k][__l];
        }
      }
    }
  }
}def conv2d_1x32x27x27_1(x37: fix<32, 16>[1][256][27][27], squeezenet0_conv10_weight: fix<32, 16>[32][256][1][1], x38: fix<32, 16>[1][32][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..32) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..256) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x37[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv10_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x38[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x32x27x27_1(x38: fix<32, 16>[1][32][27][27], squeezenet0_conv10_bias: fix<32, 16>[32], x39: fix<32, 16>[1][32][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..32) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x39[__i][__j][__k][__l] :=
                          x38[__i][__j][__k][__l] + squeezenet0_conv10_bias[__j];
        }
      }
    }
  }
}def relu_1x32x27x27_1(x39: fix<32, 16>[1][32][27][27], x40: fix<32, 16>[1][32][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..32) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          if (x39[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x40[__i][__j][__k][__l] := x39[__i][__j][__k][__l]; }
                              else { x40[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x128x27x27_2(x40: fix<32, 16>[1][32][27][27], squeezenet0_conv11_weight: fix<32, 16>[128][32][1][1], x41: fix<32, 16>[1][128][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..128) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..32) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x40[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv11_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x41[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x128x27x27_2(x41: fix<32, 16>[1][128][27][27], squeezenet0_conv11_bias: fix<32, 16>[128], x42: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x42[__i][__j][__k][__l] :=
                          x41[__i][__j][__k][__l] + squeezenet0_conv11_bias[__j];
        }
      }
    }
  }
}def relu_1x128x27x27_2(x42: fix<32, 16>[1][128][27][27], x43: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          if (x42[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x43[__i][__j][__k][__l] := x42[__i][__j][__k][__l]; }
                              else { x43[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x128x27x27_3(x40: fix<32, 16>[1][32][27][27], squeezenet0_conv12_weight: fix<32, 16>[128][32][3][3], x44: fix<32, 16>[1][128][27][27]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..128) {
              for (let __y: ubit<32> = 0..27) {
                for (let __x: ubit<32> = 0..27) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..32) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x40[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv12_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x44[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x128x27x27_3(x44: fix<32, 16>[1][128][27][27], squeezenet0_conv12_bias: fix<32, 16>[128], x45: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x45[__i][__j][__k][__l] :=
                          x44[__i][__j][__k][__l] + squeezenet0_conv12_bias[__j];
        }
      }
    }
  }
}def relu_1x128x27x27_3(x45: fix<32, 16>[1][128][27][27], x46: fix<32, 16>[1][128][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          if (x45[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x46[__i][__j][__k][__l] := x45[__i][__j][__k][__l]; }
                              else { x46[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x256x27x27_1(x43: fix<32, 16>[1][128][27][27], x46: fix<32, 16>[1][128][27][27], x48: fix<32, 16>[1][256][27][27]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x48[__i][__j][__k][__l] := x43[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..128) {
      for (let __k: ubit<5> = 0..27) {
        for (let __l: ubit<5> = 0..27) {
          x48[__i][__j + 128][__k][__l] := x46[__i][__j][__k][__l];
        }
      }
    }
  }
}def max_pool2d_1x256x13x13(x48: fix<32, 16>[1][256][27][27], x49: fix<32, 16>[1][256][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..256) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __stride_y: ubit<32> = __y * 2/*strides[0]*/;
                  let __stride_x: ubit<32> = __x * 2/*strides[1]*/;

                  let __max: fix<32, 16> = x48[__b][__c][__stride_y][__stride_x];
                  for (let __m: ubit<32> = 0..3/*pool_size[0]*/) {
                    for (let __n: ubit<32> = 0..3/*pool_size[1]*/) {
                      let __pool_y: ubit<32> = __stride_y + __m;
                      let __pool_x: ubit<32> = __stride_x + __n;
                      let __current: fix<32, 16> = x48[__b][__c][__pool_y][__pool_x];
                      if (__current > __max) { __max := __current; }
                    }
                  }
                  x49[__b][__c][__y][__x] := __max;
                }
              }
            }
          }
        
}def conv2d_1x48x13x13(x49: fix<32, 16>[1][256][13][13], squeezenet0_conv13_weight: fix<32, 16>[48][256][1][1], x50: fix<32, 16>[1][48][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..48) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..256) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x49[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv13_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x50[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x48x13x13(x50: fix<32, 16>[1][48][13][13], squeezenet0_conv13_bias: fix<32, 16>[48], x51: fix<32, 16>[1][48][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..48) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x51[__i][__j][__k][__l] :=
                          x50[__i][__j][__k][__l] + squeezenet0_conv13_bias[__j];
        }
      }
    }
  }
}def relu_1x48x13x13(x51: fix<32, 16>[1][48][13][13], x52: fix<32, 16>[1][48][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..48) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x51[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x52[__i][__j][__k][__l] := x51[__i][__j][__k][__l]; }
                              else { x52[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x192x13x13(x52: fix<32, 16>[1][48][13][13], squeezenet0_conv14_weight: fix<32, 16>[192][48][1][1], x53: fix<32, 16>[1][192][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..192) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..48) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x52[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv14_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x53[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x192x13x13(x53: fix<32, 16>[1][192][13][13], squeezenet0_conv14_bias: fix<32, 16>[192], x54: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x54[__i][__j][__k][__l] :=
                          x53[__i][__j][__k][__l] + squeezenet0_conv14_bias[__j];
        }
      }
    }
  }
}def relu_1x192x13x13(x54: fix<32, 16>[1][192][13][13], x55: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x54[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x55[__i][__j][__k][__l] := x54[__i][__j][__k][__l]; }
                              else { x55[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x192x13x13_1(x52: fix<32, 16>[1][48][13][13], squeezenet0_conv15_weight: fix<32, 16>[192][48][3][3], x56: fix<32, 16>[1][192][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..192) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..48) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x52[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv15_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x56[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x192x13x13_1(x56: fix<32, 16>[1][192][13][13], squeezenet0_conv15_bias: fix<32, 16>[192], x57: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x57[__i][__j][__k][__l] :=
                          x56[__i][__j][__k][__l] + squeezenet0_conv15_bias[__j];
        }
      }
    }
  }
}def relu_1x192x13x13_1(x57: fix<32, 16>[1][192][13][13], x58: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x57[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x58[__i][__j][__k][__l] := x57[__i][__j][__k][__l]; }
                              else { x58[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x384x13x13(x55: fix<32, 16>[1][192][13][13], x58: fix<32, 16>[1][192][13][13], x60: fix<32, 16>[1][384][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x60[__i][__j][__k][__l] := x55[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x60[__i][__j + 192][__k][__l] := x58[__i][__j][__k][__l];
        }
      }
    }
  }
}def conv2d_1x48x13x13_1(x60: fix<32, 16>[1][384][13][13], squeezenet0_conv16_weight: fix<32, 16>[48][384][1][1], x61: fix<32, 16>[1][48][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..48) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..384) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x60[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv16_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x61[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x48x13x13_1(x61: fix<32, 16>[1][48][13][13], squeezenet0_conv16_bias: fix<32, 16>[48], x62: fix<32, 16>[1][48][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..48) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x62[__i][__j][__k][__l] :=
                          x61[__i][__j][__k][__l] + squeezenet0_conv16_bias[__j];
        }
      }
    }
  }
}def relu_1x48x13x13_1(x62: fix<32, 16>[1][48][13][13], x63: fix<32, 16>[1][48][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<6> = 0..48) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x62[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x63[__i][__j][__k][__l] := x62[__i][__j][__k][__l]; }
                              else { x63[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x192x13x13_2(x63: fix<32, 16>[1][48][13][13], squeezenet0_conv17_weight: fix<32, 16>[192][48][1][1], x64: fix<32, 16>[1][192][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..192) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..48) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x63[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv17_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x64[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x192x13x13_2(x64: fix<32, 16>[1][192][13][13], squeezenet0_conv17_bias: fix<32, 16>[192], x65: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x65[__i][__j][__k][__l] :=
                          x64[__i][__j][__k][__l] + squeezenet0_conv17_bias[__j];
        }
      }
    }
  }
}def relu_1x192x13x13_2(x65: fix<32, 16>[1][192][13][13], x66: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x65[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x66[__i][__j][__k][__l] := x65[__i][__j][__k][__l]; }
                              else { x66[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x192x13x13_3(x63: fix<32, 16>[1][48][13][13], squeezenet0_conv18_weight: fix<32, 16>[192][48][3][3], x67: fix<32, 16>[1][192][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..192) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..48) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x63[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv18_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x67[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x192x13x13_3(x67: fix<32, 16>[1][192][13][13], squeezenet0_conv18_bias: fix<32, 16>[192], x68: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x68[__i][__j][__k][__l] :=
                          x67[__i][__j][__k][__l] + squeezenet0_conv18_bias[__j];
        }
      }
    }
  }
}def relu_1x192x13x13_3(x68: fix<32, 16>[1][192][13][13], x69: fix<32, 16>[1][192][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x68[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x69[__i][__j][__k][__l] := x68[__i][__j][__k][__l]; }
                              else { x69[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x384x13x13_1(x66: fix<32, 16>[1][192][13][13], x69: fix<32, 16>[1][192][13][13], x71: fix<32, 16>[1][384][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x71[__i][__j][__k][__l] := x66[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<8> = 0..192) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x71[__i][__j + 192][__k][__l] := x69[__i][__j][__k][__l];
        }
      }
    }
  }
}def conv2d_1x64x13x13(x71: fix<32, 16>[1][384][13][13], squeezenet0_conv19_weight: fix<32, 16>[64][384][1][1], x72: fix<32, 16>[1][64][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..384) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x71[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv19_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x72[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x13x13(x72: fix<32, 16>[1][64][13][13], squeezenet0_conv19_bias: fix<32, 16>[64], x73: fix<32, 16>[1][64][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x73[__i][__j][__k][__l] :=
                          x72[__i][__j][__k][__l] + squeezenet0_conv19_bias[__j];
        }
      }
    }
  }
}def relu_1x64x13x13(x73: fix<32, 16>[1][64][13][13], x74: fix<32, 16>[1][64][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x73[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x74[__i][__j][__k][__l] := x73[__i][__j][__k][__l]; }
                              else { x74[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x256x13x13(x74: fix<32, 16>[1][64][13][13], squeezenet0_conv20_weight: fix<32, 16>[256][64][1][1], x75: fix<32, 16>[1][256][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..256) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..64) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x74[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv20_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x75[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x256x13x13(x75: fix<32, 16>[1][256][13][13], squeezenet0_conv20_bias: fix<32, 16>[256], x76: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x76[__i][__j][__k][__l] :=
                          x75[__i][__j][__k][__l] + squeezenet0_conv20_bias[__j];
        }
      }
    }
  }
}def relu_1x256x13x13(x76: fix<32, 16>[1][256][13][13], x77: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x76[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x77[__i][__j][__k][__l] := x76[__i][__j][__k][__l]; }
                              else { x77[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x256x13x13_1(x74: fix<32, 16>[1][64][13][13], squeezenet0_conv21_weight: fix<32, 16>[256][64][3][3], x78: fix<32, 16>[1][256][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..256) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..64) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x74[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv21_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x78[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x256x13x13_1(x78: fix<32, 16>[1][256][13][13], squeezenet0_conv21_bias: fix<32, 16>[256], x79: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x79[__i][__j][__k][__l] :=
                          x78[__i][__j][__k][__l] + squeezenet0_conv21_bias[__j];
        }
      }
    }
  }
}def relu_1x256x13x13_1(x79: fix<32, 16>[1][256][13][13], x80: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x79[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x80[__i][__j][__k][__l] := x79[__i][__j][__k][__l]; }
                              else { x80[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x512x13x13(x77: fix<32, 16>[1][256][13][13], x80: fix<32, 16>[1][256][13][13], x82: fix<32, 16>[1][512][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x82[__i][__j][__k][__l] := x77[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x82[__i][__j + 256][__k][__l] := x80[__i][__j][__k][__l];
        }
      }
    }
  }
}def conv2d_1x64x13x13_1(x82: fix<32, 16>[1][512][13][13], squeezenet0_conv22_weight: fix<32, 16>[64][512][1][1], x83: fix<32, 16>[1][64][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..64) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..512) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x82[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv22_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x83[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x64x13x13_1(x83: fix<32, 16>[1][64][13][13], squeezenet0_conv22_bias: fix<32, 16>[64], x84: fix<32, 16>[1][64][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x84[__i][__j][__k][__l] :=
                          x83[__i][__j][__k][__l] + squeezenet0_conv22_bias[__j];
        }
      }
    }
  }
}def relu_1x64x13x13_1(x84: fix<32, 16>[1][64][13][13], x85: fix<32, 16>[1][64][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<7> = 0..64) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x84[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x85[__i][__j][__k][__l] := x84[__i][__j][__k][__l]; }
                              else { x85[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x256x13x13_2(x85: fix<32, 16>[1][64][13][13], squeezenet0_conv23_weight: fix<32, 16>[256][64][1][1], x86: fix<32, 16>[1][256][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..256) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..64) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x85[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv23_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x86[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x256x13x13_2(x86: fix<32, 16>[1][256][13][13], squeezenet0_conv23_bias: fix<32, 16>[256], x87: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x87[__i][__j][__k][__l] :=
                          x86[__i][__j][__k][__l] + squeezenet0_conv23_bias[__j];
        }
      }
    }
  }
}def relu_1x256x13x13_2(x87: fix<32, 16>[1][256][13][13], x88: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x87[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x88[__i][__j][__k][__l] := x87[__i][__j][__k][__l]; }
                              else { x88[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def conv2d_1x256x13x13_3(x85: fix<32, 16>[1][64][13][13], squeezenet0_conv24_weight: fix<32, 16>[256][64][3][3], x89: fix<32, 16>[1][256][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..256) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..64) {
                    for (let __dy: ubit<32> = 0..3/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..3/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x85[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv24_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x89[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x256x13x13_3(x89: fix<32, 16>[1][256][13][13], squeezenet0_conv24_bias: fix<32, 16>[256], x90: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x90[__i][__j][__k][__l] :=
                          x89[__i][__j][__k][__l] + squeezenet0_conv24_bias[__j];
        }
      }
    }
  }
}def relu_1x256x13x13_3(x90: fix<32, 16>[1][256][13][13], x91: fix<32, 16>[1][256][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x90[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x91[__i][__j][__k][__l] := x90[__i][__j][__k][__l]; }
                              else { x91[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def concatenate_1x512x13x13_1(x88: fix<32, 16>[1][256][13][13], x91: fix<32, 16>[1][256][13][13], x93: fix<32, 16>[1][512][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x93[__i][__j][__k][__l] := x88[__i][__j][__k][__l];
        }
      }
    }
  }
  --- 
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<9> = 0..256) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x93[__i][__j + 256][__k][__l] := x91[__i][__j][__k][__l];
        }
      }
    }
  }
}def conv2d_1x1000x13x13(x93: fix<32, 16>[1][512][13][13], squeezenet0_conv25_weight: fix<32, 16>[1000][512][1][1], x94: fix<32, 16>[1][1000][13][13]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..1000) {
              for (let __y: ubit<32> = 0..13) {
                for (let __x: ubit<32> = 0..13) {
                  let __sum: fix<32, 16> = 0.0;

                  for (let __k: ubit<32> = 0..512) {
                    for (let __dy: ubit<32> = 0..1/*kernel_size[1]*/) {
                      for (let __dx: ubit<32> = 0..1/*kernel_size[0]*/) {
                        let __kernel_y: ubit<32> = (/*strides[0]*/1 * __y) + __dy;
                        let __kernel_x: ubit<32> = (/*strides[1]*/1 * __x) + __dx;
                      } combine {
                        __sum += x93[__b][__k][__kernel_y][__kernel_x] *
                               squeezenet0_conv25_weight[__c][__k][__dy][__dx];
                      }
                    }
                  }
                  x94[__b][__c][__y][__x] := __sum;
                }
              }
            }
          }
        
}def bias_add_1x1000x13x13(x94: fix<32, 16>[1][1000][13][13], squeezenet0_conv25_bias: fix<32, 16>[1000], x95: fix<32, 16>[1][1000][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<10> = 0..1000) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          x95[__i][__j][__k][__l] :=
                          x94[__i][__j][__k][__l] + squeezenet0_conv25_bias[__j];
        }
      }
    }
  }
}def relu_1x1000x13x13(x95: fix<32, 16>[1][1000][13][13], x96: fix<32, 16>[1][1000][13][13]) = {
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<10> = 0..1000) {
      for (let __k: ubit<4> = 0..13) {
        for (let __l: ubit<4> = 0..13) {
          if (x95[__i][__j][__k][__l] > (0.0 as fix<32, 16>)) { x96[__i][__j][__k][__l] := x95[__i][__j][__k][__l]; }
                              else { x96[__i][__j][__k][__l] := (0.0 as fix<32, 16>); }
        }
      }
    }
  }
}def avg_pool2d_1x1000x1x1(x96: fix<32, 16>[1][1000][13][13], x97: fix<32, 16>[1][1000][1][1]) = {
  for (let __b: ubit<32> = 0..1) {
            for (let __c: ubit<32> = 0..1000) {
              for (let __y: ubit<32> = 0..1) {
                for (let __x: ubit<32> = 0..1) {
                  let __stride_y: ubit<32> = __y * 13/*strides[0]*/;
                  let __stride_x: ubit<32> = __x * 13/*strides[1]*/;

                  let __total: fix<32, 16> = 0.0;
                  for (let __m: ubit<32> = 0..13/*pool_size[0]*/) {
                    for (let __n: ubit<32> = 0..13/*pool_size[1]*/) {
                      let __pool_y: ubit<32> = __stride_y + __m;
                      let __pool_x: ubit<32> = __stride_x + __n;
                      let __current: fix<32, 16> = x96[__b][__c][__pool_y][__pool_x];
                      __total := __total + __current;
                    }
                  }
                  let __pool_area: fix<32, 16> = (13 as fix<32, 16>) * (13 as fix<32, 16>);
                  let __avg: fix<32, 16> = __total / __pool_area;
                  x97[__b][__c][__y][__x] := __avg;
                }
              }
            }
          }
        
}def reshape_1x1000(x97: fix<32, 16>[1][1000][1][1], x98: fix<32, 16>[1][1000]) = {
  let __m: ubit<10> = 0;
  for (let __i: ubit<1> = 0..1) {
    for (let __j: ubit<10> = 0..1000) {
      for (let __k: ubit<1> = 0..1) {
        for (let __l: ubit<1> = 0..1) {
          x98[0][__m] := x97[__i][__j][__k][__l]; __m += (1 as ubit<10>);
        }
      }
    }
  }
}